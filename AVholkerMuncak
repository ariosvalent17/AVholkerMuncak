-- =================================================================
-- ============================   UI   ==============================
-- =================================================================

local TweenService = game:GetService("TweenService")

local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()

-- WindUI Config
WindUI:AddTheme({
    Name = "Royal Void",
    Accent = WindUI:Gradient({
        ["0"]   = { Color = Color3.fromHex("#FF3366"), Transparency = 0 },  -- Merah Cerah
        ["50"]  = { Color = Color3.fromHex("#00FFFF"), Transparency = 0 },  -- Cyan Cerah
        ["100"] = { Color = Color3.fromHex("#9B30FF"), Transparency = 0 },  -- Ungu Terang
    }, {
        Rotation = 45,
    }),

    Dialog = Color3.fromHex("#0A0011"),         -- Latar hitam ke ungu gelap
    Outline = Color3.fromHex("#00FFFF"),        -- Pinggir Cyan Cerah
    Text = Color3.fromHex("#FFE6FF"),           -- Putih ke ungu muda
    Placeholder = Color3.fromHex("#B34A7F"),    -- Ungu-merah pudar
    Background = Color3.fromHex("#050008"),     -- Hitam pekat dengan nuansa ungu
    Button = Color3.fromHex("#FF00AA"),         -- Merah ke ungu neon
    Icon = Color3.fromHex("#00E5FF")            -- Aksen Cyan
})
WindUI.TransparencyValue = 0.4

local Window = WindUI:CreateWindow({
    Title = "AVholkers",
    Author = "Fish-It",
    Folder = "AVholkersHub",
    Icon = "zap",

    Size = UDim2.fromOffset(400, 200),
    Transparent = true,
    Theme = "Crimson",
    KeySystem = false,
    ScrollBarEnabled = true,
    Background = "rbxassetid://",  -- Default background
    BackgroundImageTransparency = 0.45,
    HideSearchBar = true,
    NewElements = true,
    Resizable = true,
    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function() end,
    },
})

Window:EditOpenButton({Enabled = false})

-- Toggle UI
local Chloe = Instance.new("ScreenGui")
local Button = Instance.new("ImageButton")
local Corner = Instance.new("UICorner")
local Stroke = Instance.new("UIStroke")
local Label = Instance.new("TextLabel")

-- Gradients
local StrokeGradient = Instance.new("UIGradient")
local TextGradient = Instance.new("UIGradient")

Chloe.Name = "ChloeImup"
Chloe.Parent = game:GetService("CoreGui")

Button.Name = "ChloeGemoy"
Button.Parent = Chloe
Button.Size = UDim2.new(0, 55, 0, 55)
Button.Position = UDim2.new(0, 10, 0, 50)
Button.Image = "rbxassetid://7801572665"
Button.Draggable = true
Button.Active = true

Corner.CornerRadius = UDim.new(0, 4)
Corner.Parent = Button

-- Border stroke
Stroke.Parent = Button
Stroke.Thickness = 3
Stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

-- =========================
-- GRADIENT SETUP (SAME FOR BOTH)
-- =========================
local gradientSequence = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),   -- red
    ColorSequenceKeypoint.new(0.25, Color3.fromRGB(255, 255, 0)), -- yellow
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)), -- green
    ColorSequenceKeypoint.new(0.75, Color3.fromRGB(0, 255, 255)), -- cyan
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))    -- back to red
})

-- Stroke gradient
StrokeGradient.Parent = Stroke
StrokeGradient.Color = gradientSequence
StrokeGradient.Rotation = 0

-- =========================
-- TEXT (CHILD OF BUTTON)
-- =========================
Label.Parent = Button
Label.Size = UDim2.new(1.8, 0, 0, 20)
Label.Position = UDim2.new(0.5, 0, 1, 4)
Label.AnchorPoint = Vector2.new(0.5, 0)
Label.BackgroundTransparency = 1
Label.Text = "Ato Ganteng"
Label.Font = Enum.Font.GothamBold
Label.TextSize = 14
Label.TextColor3 = Color3.fromRGB(255, 255, 255)
Label.TextXAlignment = Enum.TextXAlignment.Center
Label.TextTransparency = 0

-- Text gradient
TextGradient.Parent = Label
TextGradient.Color = gradientSequence
TextGradient.Rotation = 0

-- ==========================================================
-- üåà GRADIENT ROTATION LOOP (SYNC BUTTON + TEXT)
-- ==========================================================
local spinning = true

task.spawn(function()
    while task.wait(0.01) do
        if spinning then
            local r = (StrokeGradient.Rotation + 1) % 360
            StrokeGradient.Rotation = r
            TextGradient.Rotation = r
        end
    end
end)

-- ==========================================================
-- üî¥üü¢ BLINK ON CLICK (PAUSE GRADIENT)
-- ==========================================================
local function blink(color)
    spinning = false

    StrokeGradient.Enabled = false
    TextGradient.Enabled = false
    Stroke.Color = color
    Label.TextColor3 = color

    local tweenIn = TweenService:Create(Stroke, TweenInfo.new(0.2), { Transparency = 1 })
    local tweenOut = TweenService:Create(Stroke, TweenInfo.new(0.2), { Transparency = 0 })

    tweenIn:Play()
    tweenIn.Completed:Wait()
    tweenOut:Play()
    tweenOut.Completed:Wait()

    StrokeGradient.Enabled = true
    TextGradient.Enabled = true
    spinning = true
end

-- ==========================================================
-- OPEN / CLOSE
-- ==========================================================
local isWindowOpen = true

Button.MouseButton1Click:Connect(function()
    if isWindowOpen then
        Window:Close()
        blink(Color3.fromRGB(255, 0, 0)) -- close = red
    else
        Window:Open()
        blink(Color3.fromRGB(0, 255, 0)) -- open = green
    end
    isWindowOpen = not isWindowOpen
end)




--================================================--
-- üßæ OVERHEAD / NAME & LEVEL EDITOR (FINAL)
--================================================--

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Ambil object Overhead
local Characters = workspace:FindFirstChild("Characters"):WaitForChild(LocalPlayer.Name)
local HRP = Characters:WaitForChild("HumanoidRootPart")
local Overhead = HRP:WaitForChild("Overhead")

local Header = Overhead:WaitForChild("Content"):WaitForChild("Header")
local LevelLabel = Overhead:WaitForChild("LevelContainer"):WaitForChild("Label")
local TitleContainer = Overhead:WaitForChild("TitleContainer")
local TitleLabel = TitleContainer:WaitForChild("Label")

local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local XPBar = PlayerGui:WaitForChild("XP")
local XPLevel = XPBar:WaitForChild("Frame"):WaitForChild("LevelCount")

--------------------------------------------------
-- SIMPAN KONDISI ASLI (PENTING)
--------------------------------------------------
local Original = {
    Name = Header.Text,
    LevelOverhead = LevelLabel.Text,
    XPLevel = XPLevel.Text,
    Title = TitleLabel.Text,
    TitleVisible = TitleContainer.Visible,

    NameSize = Header.TextSize,
    LevelSize = LevelLabel.TextSize,
    TitleSize = TitleLabel.TextSize
}

--------------------------------------------------
-- STATE
--------------------------------------------------
local OverheadState = {
    Enabled = false,

    CustomName = nil,
    CustomLevel = nil,
    CustomXP = nil,
    CustomTitle = nil,

    NameSize = Original.NameSize,
    LevelSize = Original.LevelSize,
    TitleSize = Original.TitleSize
}

--------------------------------------------------
-- HELPER
--------------------------------------------------
local function forceTextSize(label, size)
    if label and size then
        label.TextScaled = false
        label.TextSize = size
    end
end

--------------------------------------------------
-- TAB PROFILE
--------------------------------------------------
local ProfileTab = Window:Tab({
    Title = "Profile",
    Icon = "user",
    Locked = false, 
    ShowTabTitle = true 
})

local ProfileSection = ProfileTab:Section({
    Title = "Overhead Editor",
    Opened = true
})

--------------------------------------------------
-- TOGGLE ENABLE
--------------------------------------------------
ProfileSection:Toggle({
    Title = "Enable Overhead Editor",
    Desc = "Aktif / nonaktifkan custom overhead",
    Value = false,
    Callback = function(state)
        OverheadState.Enabled = state

        if state then
            -- ENABLE
            TitleContainer.Visible = true

            if OverheadState.CustomName then
                Header.Text = OverheadState.CustomName
            end

            if OverheadState.CustomLevel then
                local prefix = Original.LevelOverhead:match("^(.-)%s*%d+$")
                if prefix then
                    LevelLabel.Text = prefix .. " " .. OverheadState.CustomLevel
                end
            end

            if OverheadState.CustomXP then
                XPLevel.Text = tostring(OverheadState.CustomXP)
            end

            if OverheadState.CustomTitle then
                TitleLabel.Text = OverheadState.CustomTitle
            end

            forceTextSize(Header, OverheadState.NameSize)
            forceTextSize(LevelLabel, OverheadState.LevelSize)
            forceTextSize(TitleLabel, OverheadState.TitleSize)

        else
            -- DISABLE (RESET TOTAL)
            Header.Text = Original.Name
            LevelLabel.Text = Original.LevelOverhead
            XPLevel.Text = Original.XPLevel
            TitleLabel.Text = Original.Title
            TitleContainer.Visible = Original.TitleVisible

            forceTextSize(Header, Original.NameSize)
            forceTextSize(LevelLabel, Original.LevelSize)
            forceTextSize(TitleLabel, Original.TitleSize)

            OverheadState.NameSize = Original.NameSize
            OverheadState.LevelSize = Original.LevelSize
            OverheadState.TitleSize = Original.TitleSize
        end
    end
})

--------------------------------------------------
-- EDIT NAMA
--------------------------------------------------
ProfileSection:Input({
    Title = "Custom Name",
    Desc = "Ganti nama di overhead (visual)",
    Placeholder = Original.Name,
    Callback = function(text)
        if text and text ~= "" then
            OverheadState.CustomName = text
            if OverheadState.Enabled then
                Header.Text = text
            end
        end
    end
})

--------------------------------------------------
-- EDIT LEVEL (ANGKA SAJA)
--------------------------------------------------
ProfileSection:Input({
    Title = "Custom Level (Overhead)",
    Desc = "Hanya mengubah angka (Lvl: tetap)",
    Placeholder = Original.LevelOverhead,
    Callback = function(text)
        local num = tonumber(text)
        if not num then return end
        OverheadState.CustomLevel = num

        if OverheadState.Enabled then
            local prefix = Original.LevelOverhead:match("^(.-)%s*%d+$")
            if prefix then
                LevelLabel.Text = prefix .. " " .. num
            end
        end
    end
})

--------------------------------------------------
-- EDIT XP BAR LEVEL
--------------------------------------------------
ProfileSection:Input({
    Title = "Custom Level (XP Bar)",
    Desc = "Ganti level di XP bar",
    Placeholder = Original.XPLevel,
    Callback = function(text)
        local num = tonumber(text)
        if not num then return end
        OverheadState.CustomXP = num
        if OverheadState.Enabled then
            XPLevel.Text = tostring(num)
        end
    end
})

--------------------------------------------------
-- EDIT TITLE
--------------------------------------------------
ProfileSection:Input({
    Title = "Custom Title",
    Desc = "Ganti title player",
    Placeholder = Original.Title,
    Callback = function(text)
        if text and text ~= "" then
            OverheadState.CustomTitle = text
            if OverheadState.Enabled then
                TitleLabel.Text = text
            end
        end
    end
})

--------------------------------------------------
-- SLIDER UKURAN
--------------------------------------------------
ProfileSection:Slider({
    Title = "Name Size",
    Value = { Min = 1, Max = 50, Default = Original.NameSize },
    Step = 1,
    Callback = function(v)
        OverheadState.NameSize = v
        if OverheadState.Enabled then
            forceTextSize(Header, v)
        end
    end
})

ProfileSection:Slider({
    Title = "Level Size",
    Value = { Min = 1, Max = 50, Default = Original.LevelSize },
    Step = 1,
    Callback = function(v)
        OverheadState.LevelSize = v
        if OverheadState.Enabled then
            forceTextSize(LevelLabel, v)
        end
    end
})

ProfileSection:Slider({
    Title = "Title Size",
    Value = { Min = 1, Max = 50, Default = Original.TitleSize },
    Step = 1,
    Callback = function(v)
        OverheadState.TitleSize = v
        if OverheadState.Enabled then
            forceTextSize(TitleLabel, v)
        end
    end
})
---end

-- ================================================================
-- ===============  SYSTEM PANEL: CPU & PING MONITOR  =============
-- ================================================================

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Stats = game:GetService("Stats")

local SystemTab = Window:Tab({
    Title = "System Panel",
    Icon = "cpu",
    ShowTabTitle = true
})

-- =========================
-- PANEL UI (MINI + AUTO CENTER)
-- =========================
local SystemGUI = Instance.new("ScreenGui")
local Panel = Instance.new("Frame")
local Corner = Instance.new("UICorner")
local Stroke = Instance.new("UIStroke")
local PingLabel = Instance.new("TextLabel")
local CpuLabel = Instance.new("TextLabel")
local Layout = Instance.new("UIListLayout")
local Padding = Instance.new("UIPadding")

SystemGUI.Name = "SystemMonitor"
SystemGUI.Parent = game:GetService("CoreGui")
SystemGUI.Enabled = false

Panel.Parent = SystemGUI
Panel.Size = UDim2.new(0, 130, 0, 55)
Panel.Position = UDim2.new(1, -150, 0, 55)
Panel.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
Panel.BackgroundTransparency = 0.35

Corner.Parent = Panel
Corner.CornerRadius = UDim.new(0, 8)

Stroke.Parent = Panel
Stroke.Color = Color3.fromRGB(255, 0, 0)
Stroke.Thickness = 2

-- Padding (jarak tepi)
Padding.Parent = Panel
Padding.PaddingTop = UDim.new(0, 6)
Padding.PaddingBottom = UDim.new(0, 6)
Padding.PaddingLeft = UDim.new(0, 6)
Padding.PaddingRight = UDim.new(0, 6)

-- Layout auto center
Layout.Parent = Panel
Layout.FillDirection = Enum.FillDirection.Vertical
Layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
Layout.VerticalAlignment = Enum.VerticalAlignment.Center
Layout.Padding = UDim.new(0, 2)

-- Ping Label
PingLabel.Parent = Panel
PingLabel.Size = UDim2.new(1, 0, 0, 16)
PingLabel.BackgroundTransparency = 1
PingLabel.Font = Enum.Font.GothamBold
PingLabel.TextSize = 12
PingLabel.TextXAlignment = Enum.TextXAlignment.Left
PingLabel.Text = "Ping: ..."

-- CPU Label
CpuLabel.Parent = Panel
CpuLabel.Size = UDim2.new(1, 0, 0, 16)
CpuLabel.BackgroundTransparency = 1
CpuLabel.Font = Enum.Font.GothamBold
CpuLabel.TextSize = 12
CpuLabel.TextXAlignment = Enum.TextXAlignment.Left
CpuLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CpuLabel.Text = "CPU: ..."

-- ============================================================
-- PANEL DRAGGABLE
-- ============================================================
local dragging = false
local dragStart, startPos

Panel.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1
    or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = Panel.Position
    end
end)

Panel.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1
    or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (
        input.UserInputType == Enum.UserInputType.MouseMovement
        or input.UserInputType == Enum.UserInputType.Touch
    ) then
        local delta = input.Position - dragStart
        Panel.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

-- ============================================================
-- MONITOR LOOP (CPU ms stabil)
-- ============================================================
local monitoring = false
local lastUpdate = 0
local cpu_ms = 0

task.spawn(function()
    while task.wait() do
        if monitoring then
            -- Ambil DeltaTime akurat
            local dt = RunService.RenderStepped:Wait()
            cpu_ms = math.floor(dt * 1000 * 10) / 10  -- ms

            -- Update UI lebih stabil (0.35 detik)
            if tick() - lastUpdate >= 0.35 then
                lastUpdate = tick()

                -- Ping asli
                local ping = math.floor(
                    Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
                )

                -- Warna ping
                local pingColor
                if ping <= 80 then
                    pingColor = Color3.fromRGB(0, 255, 0)       -- hijau
                elseif ping <= 150 then
                    pingColor = Color3.fromRGB(255, 255, 0)     -- kuning
                else
                    pingColor = Color3.fromRGB(255, 0, 0)       -- merah
                end

                PingLabel.Text = "Ping: " .. ping .. " ms"
                PingLabel.TextColor3 = pingColor

                CpuLabel.Text = "CPU: " .. cpu_ms .. " ms"
            end
        end
    end
end)

-- =========================
-- TOGGLE DI TAB
-- =========================
SystemTab:Toggle({
    Title = "Enable CPU & Ping Panel",
    Value = false,
    Callback = function(v)
        monitoring = v
        SystemGUI.Enabled = v
    end
})


-- =========================
-- FPS BOOSTER SYSTEM
-- =========================

local lighting = game:GetService("Lighting")
local starterGui = game:GetService("StarterGui")
local isBoosting = false

-- Backup original settings
local originalSettings = {
    GlobalShadows = lighting.GlobalShadows,
    Brightness = lighting.Brightness,
    FogEnd = lighting.FogEnd,
    EnvironmentSpecularScale = lighting.EnvironmentSpecularScale,
    EnvironmentDiffuseScale = lighting.EnvironmentDiffuseScale,
    Technology = lighting.Technology,
}

-- Function to remove laggy objects
local function RemoveLagObjects()
    for _, v in ipairs(workspace:GetDescendants()) do
        if v:IsA("ParticleEmitter")
        or v:IsA("Trail")
        or v:IsA("Smoke")
        or v:IsA("Fire")
        or v:IsA("Sparkles")
        then
            v.Enabled = false
        end
    end
end

local function RestoreLagObjects()
    for _, v in ipairs(workspace:GetDescendants()) do
        if v:IsA("ParticleEmitter")
        or v:IsA("Trail")
        or v:IsA("Smoke")
        or v:IsA("Fire")
        or v:IsA("Sparkles")
        then
            v.Enabled = true
        end
    end
end

-- Function for FPS Boost ON
local function EnableFPSBoost()
    isBoosting = true

    -- Remove lag objects
    RemoveLagObjects()

    -- Disable Shadows
    lighting.GlobalShadows = false

    -- Lower brightness
    lighting.Brightness = 1

    -- Fog close (less render distance)
    lighting.FogEnd = 100

    -- Kill reflections
    lighting.EnvironmentSpecularScale = 0
    lighting.EnvironmentDiffuseScale = 0

    -- Force performance mode
    pcall(function()
        lighting.Technology = Enum.Technology.Compatibility
    end)

    -- Disable Screen Effects
    for _, v in ipairs(lighting:GetChildren()) do
        if v:IsA("BlurEffect")
        or v:IsA("DepthOfFieldEffect")
        or v:IsA("BloomEffect")
        or v:IsA("ColorCorrectionEffect")
        then
            v.Enabled = false
        end
    end

    -- Lower Mesh LOD
    settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Low
end

-- Function for FPS Boost OFF
local function DisableFPSBoost()
    isBoosting = false

    -- Restore particles
    RestoreLagObjects()

    -- Restore lighting
    lighting.GlobalShadows = originalSettings.GlobalShadows
    lighting.Brightness = originalSettings.Brightness
    lighting.FogEnd = originalSettings.FogEnd
    lighting.EnvironmentSpecularScale = originalSettings.EnvironmentSpecularScale
    lighting.EnvironmentDiffuseScale = originalSettings.EnvironmentDiffuseScale

    -- Restore rendering tech
    pcall(function()
        lighting.Technology = originalSettings.Technology
    end)

    -- Re-enable effects
    for _, v in ipairs(lighting:GetChildren()) do
        if v:IsA("BlurEffect")
        or v:IsA("DepthOfFieldEffect")
        or v:IsA("BloomEffect")
        or v:IsA("ColorCorrectionEffect")
        then
            v.Enabled = true
        end
    end

    settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.High
end

-- =========================
-- TOGGLE UI
-- =========================
SystemTab:Toggle({
    Title = "FPS Booster",
    Value = false,
    Callback = function(v)
        if v then
            EnableFPSBoost()
        else
            DisableFPSBoost()
        end
    end
})

-- =========================
-- REDUCE MAP SYSTEM (ONLY SKIP NPC)
-- =========================

local reduceMapEnabled = false
local mapBackup = {
    Parts = {},
    Decals = {},
    Textures = {},
}

-- üîí CUKUP CEK INI SAJA
local function IsNPC(obj)
    local model = obj:FindFirstAncestorOfClass("Model")
    return model and model:FindFirstChildOfClass("Humanoid")
end

-- Backup kondisi map (sekali saja)
local function BackupMap()
    for _, v in ipairs(workspace:GetDescendants()) do
        if IsNPC(v) then
            continue
        end

        if v:IsA("BasePart") then
            mapBackup.Parts[v] = {
                Material = v.Material,
                Reflectance = v.Reflectance,
                CastShadow = v.CastShadow,
            }
        elseif v:IsA("Decal") then
            mapBackup.Decals[v] = {
                Transparency = v.Transparency
            }
        elseif v:IsA("Texture") then
            mapBackup.Textures[v] = {
                Transparency = v.Transparency
            }
        end
    end
end

-- Reduce Map ON
local function EnableReduceMap()
    reduceMapEnabled = true

    if next(mapBackup.Parts) == nil then
        BackupMap()
    end

    for _, v in ipairs(workspace:GetDescendants()) do
        if IsNPC(v) then
            continue
        end

        if v:IsA("BasePart") then
            v.Material = Enum.Material.Plastic
            v.Reflectance = 0
            v.CastShadow = false
        elseif v:IsA("Decal") or v:IsA("Texture") then
            v.Transparency = 1
        end
    end

    -- Terrain ringan (aman untuk NPC)
    pcall(function()
        workspace.Terrain.WaterTransparency = 1
        workspace.Terrain.WaterWaveSize = 0
        workspace.Terrain.WaterWaveSpeed = 0
    end)
end

-- Reduce Map OFF (Restore)
local function DisableReduceMap()
    reduceMapEnabled = false

    for part, data in pairs(mapBackup.Parts) do
        if part and part.Parent then
            part.Material = data.Material
            part.Reflectance = data.Reflectance
            part.CastShadow = data.CastShadow
        end
    end

    for decal, data in pairs(mapBackup.Decals) do
        if decal and decal.Parent then
            decal.Transparency = data.Transparency
        end
    end

    for texture, data in pairs(mapBackup.Textures) do
        if texture and texture.Parent then
            texture.Transparency = data.Transparency
        end
    end
end

-- =========================
-- TOGGLE UI
-- =========================
SystemTab:Toggle({
    Title = "Reduce Map (NPC Safe)",
    Value = false,
    Callback = function(v)
        if v then
            EnableReduceMap()
        else
            DisableReduceMap()
        end
    end
})

---end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

local Modules = {}
local function customRequire(module)
    if not module then return nil end
    local success, result = pcall(require, module)
    if success then
        return result
    else
        local clone = module:Clone()
        clone.Parent = nil
        local cloneSuccess, cloneResult = pcall(require, clone)
        if cloneSuccess then
            return cloneResult
        else
            warn("Failed to load module: " .. module:GetFullName())
            return nil
        end
    end
end

local success, errorMessage = pcall(function()
    local Controllers = ReplicatedStorage:WaitForChild("Controllers", 20)
    local NetFolder = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild(
        "sleitnick_net@0.2.0"):WaitForChild("net", 20)
    local Shared = ReplicatedStorage:WaitForChild("Shared", 20)
    
    if not (Controllers and NetFolder and Shared) then error("Core game folders not found.") end

    Modules.Replion = customRequire(ReplicatedStorage.Packages.Replion)
    Modules.ItemUtility = customRequire(Shared.ItemUtility)
    Modules.FishingController = customRequire(Controllers.FishingController)
    
    Modules.EquipToolEvent = NetFolder["RE/EquipToolFromHotbar"]
    Modules.ChargeRodFunc = NetFolder["RF/ChargeFishingRod"]
    Modules.StartMinigameFunc = NetFolder["RF/RequestFishingMinigameStarted"]
    Modules.CompleteFishingEvent = NetFolder["RE/FishingCompleted"]
end)

if not success then
    warn("FATAL ERROR DURING MODULE LOADING: " .. tostring(errorMessage))
    return
end

task.wait(1)



local FishingSection = Window:Section({ Title = "X5 Speed Auto Fishing", Opened = true })
local FishingTab = FishingSection:Tab({ Title = "Blatant X5", Icon = "fish", ShowTabTitle = true })

local Config = Window.ConfigManager:CreateConfig("x5speedFishingSettings")

local featureState = {
    AutoFish = false,
    x5speed_ChargeDelay = 0.07,
    x5speed_SpamCount = 5,
    x5speed_WorkerCount = 2,
    x5speed_StartDelay = 1.20,
    x5speed_CatchTimeout = 0.01,
    x5speed_CycleDelay = 0.01,
    x5speed_ResetCount = Config:Get("x5speed_ResetCount") or 10,
    x5speed_ResetPause = Config:Get("x5speed_ResetPause") or 0.01
}

local fishingTrove = {}
local autoFishThread = nil
local isWaitingForCorrectTier = false
local fishCaughtBindable = Instance.new("BindableEvent")


local function equipFishingRod()
    if Modules.EquipToolEvent then
        pcall(Modules.EquipToolEvent.FireServer, Modules.EquipToolEvent, 1)
    end
end

task.spawn(function()
    local lastFishName = ""
    while task.wait(0.25) do
        local playerGui = player:findFirstChild("PlayerGui")
        if playerGui then
            local notificationGui = playerGui:FindFirstChild("Small Notification")
            if notificationGui and notificationGui.Enabled then
                local container = notificationGui:FindFirstChild("Display", true) and
                    notificationGui.Display:FindFirstChild("Container", true)
                if container then
                    local itemNameLabel = container:FindFirstChild("ItemName")
                    if itemNameLabel and itemNameLabel.Text ~= "" and itemNameLabel.Text ~= lastFishName then
                        lastFishName = itemNameLabel.Text
                        fishCaughtBindable:Fire()
                    end
                end
            else
                lastFishName = ""
            end
        end
    end
end)

local function stopAutoFishProcesses()
    featureState.AutoFish = false
    
    for i, item in ipairs(fishingTrove) do
        if typeof(item) == "RBXScriptConnection" then
            item:Disconnect()
        elseif typeof(item) == "thread" then
            task.cancel(item)
        end
    end
    fishingTrove = {}
    
    pcall(function()
        if Modules.FishingController and Modules.FishingController.RequestClientStopFishing then
            Modules.FishingController:RequestClientStopFishing(true)
        end
    end)
end

local function startAutoFishMethod_x5speed()
    if not (Modules.ChargeRodFunc and Modules.StartMinigameFunc and Modules.CompleteFishingEvent and Modules.FishingController) then
        return
    end

    featureState.AutoFish = true

    local chargeCount = 0
    local isCurrentlyResetting = false
    local counterLock = false

    local function worker()
        while featureState.AutoFish and player do
            local currentResetTarget_Worker = featureState.x5speed_ResetCount or 10

            if isCurrentlyResetting or chargeCount >= currentResetTarget_Worker then
                break
            end

            local success, err = pcall(function()
                while counterLock do task.wait() end
                counterLock = true

                if chargeCount < currentResetTarget_Worker then
                    chargeCount = chargeCount + 1
                else
                    counterLock = false
                    return
                end
                counterLock = false

                Modules.ChargeRodFunc:InvokeServer(nil, nil, nil, workspace:GetServerTimeNow())
                task.wait(featureState.x5speed_ChargeDelay)
                Modules.StartMinigameFunc:InvokeServer(-139, 1, workspace:GetServerTimeNow())
                task.wait(featureState.x5speed_StartDelay)

                if not featureState.AutoFish or isCurrentlyResetting then return end

                for _ = 1, featureState.x5speed_SpamCount do
                    if not featureState.AutoFish or isCurrentlyResetting then break end
                    Modules.CompleteFishingEvent:FireServer()
                    task.wait(0.03)
                end

                if not featureState.AutoFish or isCurrentlyResetting then return end

                local gotFishSignal = false
                local connection
                local timeoutThread = task.delay(featureState.x5speed_CatchTimeout, function()
                    if not gotFishSignal and connection and connection.Connected then
                        connection:Disconnect()
                    end
                end)

                connection = fishCaughtBindable.Event:Connect(function()
                    if gotFishSignal then return end
                    gotFishSignal = true
                    task.cancel(timeoutThread)
                    if connection and connection.Connected then
                        connection:Disconnect()
                    end
                end)

                while not gotFishSignal and task.wait() do
                    if not featureState.AutoFish or isCurrentlyResetting then break end
                    if timeoutThread and coroutine.status(timeoutThread) == "dead" then break end
                end

                if connection and connection.Connected then connection:Disconnect() end

                if Modules.FishingController and Modules.FishingController.RequestClientStopFishing then
                    pcall(Modules.FishingController.RequestClientStopFishing, Modules.FishingController, true)
                end

                task.wait()
            end)

            if not success then
                warn("AVholkers Auto x5speed Fish Error: ", err)
                task.wait(1)
            end

            if not featureState.AutoFish then break end
            task.wait(featureState.x5speed_CycleDelay)
        end
    end

    autoFishThread = task.spawn(function()
        while featureState.AutoFish do
            local currentResetTarget = featureState.x5speed_ResetCount or 10
            local currentPauseTime = featureState.x5speed_ResetPause or 0.01

            chargeCount = 0
            isCurrentlyResetting = false

            local batchTrove = {}

            for i = 1, featureState.x5speed_WorkerCount do
                if not featureState.AutoFish then break end
                local workerThread = task.spawn(worker)
                table.insert(batchTrove, workerThread)
                table.insert(fishingTrove, workerThread)
            end

            while featureState.AutoFish and chargeCount < currentResetTarget do
                task.wait()
            end

            isCurrentlyResetting = true

            if featureState.AutoFish then
                for _, thread in ipairs(batchTrove) do
                    task.cancel(thread)
                end
                batchTrove = {}

                task.wait(currentPauseTime)
            end
        end
        stopAutoFishProcesses()
    end)

    table.insert(fishingTrove, autoFishThread)
end

local function startOrStopAutoFish(shouldStart)
    if shouldStart then
        stopAutoFishProcesses()
        featureState.AutoFish = true
        equipFishingRod()
        task.wait(0.01)
        startAutoFishMethod_x5speed()
    else
        stopAutoFishProcesses()
    end
end

FishingTab:Section({ Title = "Settings", Opened = true })

local startDelaySlider = FishingTab:Slider({
    Title = "Delay Recast",
    Desc = "(Default: 1.20)",
    Value = { Min = 0.00, Max = 5.0, Default = featureState.x5speed_StartDelay },
    Precise = 2,
    Step = 0.01,
    Callback = function(v)
        featureState.x5speed_StartDelay = tonumber(v)
    end
})
Config:Register("x5speed_StartDelay", startDelaySlider)

local resetCountSlider = FishingTab:Slider({
    Title = "Spam Finish",
    Desc = "(Default: 10)",
    Value = { Min = 5, Max = 50, Default = featureState.x5speed_ResetCount },
    Precise = 0,
    Step = 1,
    Callback = function(v)
        local num = math.floor(tonumber(v) or 10)
        featureState.x5speed_ResetCount = num
        Config:Set("x5speed_ResetCount", num)
    end
})
Config:Register("x5speed_ResetCount", resetCountSlider)

local resetPauseSlider = FishingTab:Slider({
    Title = "Cooldown Recast",
    Desc = "(Default: 0.01)",
    Value = { Min = 0.00, Max = 5, Default = featureState.x5speed_ResetPause },
    Precise = 2,
    Step = 0.01,
    Callback = function(v)
        local num = tonumber(v) or 2.0
        featureState.x5speed_ResetPause = num
        Config:Set("x5speed_ResetPause", num)
    end
})
Config:Register("x5speed_ResetPause", resetPauseSlider)

FishingTab:Section({ Title = "AutoFish X5 Speed", Opened = true })

local autoFishToggle = FishingTab:Toggle({
    Title = "AutoFish",
    Desc = "still unstable and lots of bugs.",
    Value = false,
    Callback = startOrStopAutoFish
})
Config:Register("AutoFish", autoFishToggle)

local stopAnimConnections = {}
local function setGameAnimationsEnabled(state)
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    for _, conn in pairs(stopAnimConnections) do
        conn:Disconnect()
    end
    stopAnimConnections = {}

    if state then
        
        for _, track in ipairs(humanoid:FindFirstChildOfClass("Animator"):GetPlayingAnimationTracks()) do
            track:Stop(0)
        end

        local conn = humanoid:FindFirstChildOfClass("Animator").AnimationPlayed:Connect(function(track)
            task.defer(function()
                track:Stop(0)
            end)
        end)
        table.insert(stopAnimConnections, conn)

        WindUI:Notify({
            Title = "Animation Disabled",
            Content = "All animations from the game have been disabled..",
            Duration = 4,
            Icon = "pause-circle"
        })
    else
        
        for _, conn in pairs(stopAnimConnections) do
            conn:Disconnect()
        end
        stopAnimConnections = {}

        WindUI:Notify({
            Title = "Animation Enabled",
            Content = "Animations from the game are reactivated.",
            Duration = 4,
            Icon = "play-circle"
        })
    end
end

local gameAnimToggle = FishingTab:Toggle({
    Title = "No Animation",
    Desc = "Stop all animations from the game.",
    Value = false,
    Callback = function(v)
        setGameAnimationsEnabled(v)
    end
})
Config:Register("DisableGameAnimations", gameAnimToggle)



if Window then
    Window:SelectTab(1)
    WindUI:Notify({
        Title = "Hehehehe :p",
        Content = "Welcome To Vholker Exploit",
        Duration = 5,
        Icon = "check-circle"
    })
end


-- [[ Services Caller Shorcut ]]
local svc = {
	Players = game:GetService("Players"),
	RS = game:GetService("ReplicatedStorage"),
}

-- [[ Local Player + Hrp ]]
local player = svc.Players.LocalPlayer
local hrp = player.Character and player.Character:WaitForChild("HumanoidRootPart") or player.CharacterAdded:Wait():WaitForChild("HumanoidRootPart")

-- [[ Require for RemoteFunction + RemoteEvent Shortcut ]]
local mods = {
	Net = svc.RS.Packages._Index["sleitnick_net@0.2.0"].net,
	Replion = require(svc.RS.Packages.Replion),
}

-- [[ API Caller from shorcut ]]
local api = {
	-- [[ Remote Event ]]
	Events = {
		REFishDone = mods.Net["RE/FishingCompleted"],
	},
	-- [[ Remote Function ]]
	Functions = {
		ChargeRod = mods.Net["RF/ChargeFishingRod"],
		StartMini = mods.Net["RF/RequestFishingMinigameStarted"],
		Cancel = mods.Net["RF/CancelFishingInputs"],
		Done = mods.Net["RF/RequestFishingMinigameStarted"],
		AutoEnabled = mods.Net["RF/UpdateAutoFishingState"],
	},
}


local Fish10 = FishingSection:Tab({
    Title = "Blantant Update X11",
    Icon = "fish",
    Locked = false, 
    ShowTabTitle = true 
})

-- [[ PROTECTED BLATANT ]]
local ThreadGuard = { _sessions = {} }

function ThreadGuard:Next(key)
	self._sessions[key] = (self._sessions[key] or 0) + 1
	return self._sessions[key]
end

function ThreadGuard:IsAlive(key, session)
	return self._sessions[key] == session
end

local TG = ThreadGuard


-- [[ Function Blatant ]]
function Fastest2(session)
	while Protected and TG:IsAlive("BlatantBeta", session) do
		task.spawn(function()
			if not TG:IsAlive("BlatantBeta", session) then
				return
			end
			local now = workspace:GetServerTimeNow()
			api.Functions.ChargeRod:InvokeServer(now) -- Charge Started 
		end)
		task.spawn(function()
			if not TG:IsAlive("BlatantBeta", session) then
				return
			end
			local started = workspace:GetServerTimeNow()
			api.Functions.StartMini:InvokeServer(-1, 1, started) -- Start minigame 
		end)
		task.wait(_G.FishingDelay2)
		if not TG:IsAlive("BlatantBeta", session) then
			break
		end
		task.spawn(function()
			if not TG:IsAlive("BlatantBeta", session) then
				return
			end
			api.Events.REFishDone:FireServer() -- Complete Fishing (Delay Bait)
		end)
		task.wait(_G.Reel2)
		if not TG:IsAlive("BlatantBeta", session) then
			break
		end
		task.spawn(function()
			if not TG:IsAlive("BlatantBeta", session) then
				return
			end
			api.Functions.Cancel:InvokeServer() -- Cancel Fishing (Delay Cast)
		end)
	end
end

Fish10:Input({
	Title = "Delay Bait",
	Value = tostring(_G.Reel2),
	Callback = function(v)
		local n = tonumber(v)
		if n and n > 0 then
			_G.Reel2 = n
		end
	end,
})

Fish10:Input({
	Title = "Delay Cast",
	Value = tostring(_G.FishingDelay2),
	Callback = function(v)
		local n = tonumber(v)
		if n and n > 0 then
			_G.FishingDelay2 = n
		end
	end,
})

Fish10:Toggle({
	Title = "Stable Result v2",
	Default = _G.FStable2,
	Callback = function(s)
		_G.FStable2 = s
	end,
})

Fish10:Toggle({
	Title = "Blatant Fishing v2",
	Default = _G.FBlatant2,
	Callback = function(s)
		if _G.FBlatant2 == s then
			return
		end
		_G.FBlatant2 = s

		api.Functions.AutoEnabled:InvokeServer(s and _G.FStable2) -- for byoassed auto from games

		local session = TG:Next("BlatantBeta")

		if s then
			Protected = true
			player:SetAttribute("Loading", nil) -- bypassed character not casting
			task.spawn(function()
				Fastest2(session)
			end)
		else
			Protected = false
			player:SetAttribute("Loading", false) -- back normal
			TG:Next("BlatantBeta")
		end
	end,
})

Fish10:Button({
	Title = "Recovery Fishing",
	Callback = function()
		task.spawn(function()
			api.Functions.Cancel:InvokeServer()
		end)
	end,
})
---end x11

local Legit = Window:Tab({
    Title = "|Legit Fishing",
    Icon = "fish",
    Locked = false,
    ShowTabTitle = true 
})


Window:SetIconSize(40)

Window:SetToggleKey(Enum.KeyCode.G)


-- Notify
local function NotifySuccess(title, message, duration)
    WindUI:Notify({
        Title = title,
        Content = message,
        Duration = duration,
        Icon = "circle-check"
    })
end

local function NotifyError(title, message, duration)
    WindUI:Notify({
        Title = title,
        Content = message,
        Duration = duration,
        Icon = "ban"
    })
end

local function NotifyInfo(title, message, duration)
    WindUI:Notify({
        Title = title,
        Content = message,
        Duration = duration,
        Icon = "info"
    })
end

local function NotifyWarning(title, message, duration)
    WindUI:Notify({
        Title = title,
        Content = message,
        Duration = duration,
        Icon = "triangle-alert"
    })
end


---------------------------------------------------
-- START: Fitur Legit Auto Fishing Kamu
---------------------------------------------------

-- Parameters
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local net = ReplicatedStorage:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

local VirtualUser = game:GetService("VirtualUser")
local rodRemote = net:WaitForChild("RF/ChargeFishingRod")
local miniGameRemote = net:WaitForChild("RF/RequestFishingMinigameStarted")
local finishRemote = net:WaitForChild("RE/FishingCompleted")
local Constants = require(ReplicatedStorage:WaitForChild("Shared", 20):WaitForChild("Constants"))

_G.Characters = workspace:FindFirstChild("Characters"):WaitForChild(LocalPlayer.Name)
_G.HRP = _G.Characters:WaitForChild("HumanoidRootPart")
_G.Overhead = _G.HRP:WaitForChild("Overhead")
_G.Header = _G.Overhead:WaitForChild("Content"):WaitForChild("Header")
_G.LevelLabel = _G.Overhead:WaitForChild("LevelContainer"):WaitForChild("Label")
local Player = Players.LocalPlayer
local XPBar = Player:WaitForChild("PlayerGui"):WaitForChild("XP")
_G.XPLevel = XPBar:WaitForChild("Frame"):WaitForChild("LevelCount")
_G.Title = _G.Overhead:WaitForChild("TitleContainer"):WaitForChild("Label")
_G.TitleEnabled = _G.Overhead:WaitForChild("TitleContainer")

if Player and VirtualUser then
    Player.Idled:Connect(function()
        pcall(function()
            VirtualUser:CaptureController(); VirtualUser:ClickButton2(Vector2.new())
        end)
    end)
end

task.spawn(function()
    if XPBar then
        XPBar.Enabled = true
    end
end)


-- AUTO RECONNECT
local TeleportService = game:GetService("TeleportService")
local PlaceId = game.PlaceId

local function AutoReconnect()
    while task.wait(5) do
        if not Players.LocalPlayer or not Players.LocalPlayer:IsDescendantOf(game) then
            TeleportService:Teleport(PlaceId)
        end
    end
end

Players.LocalPlayer.OnTeleport:Connect(function(state)
    if state == Enum.TeleportState.Failed then
        TeleportService:Teleport(PlaceId)
    end
end)

task.spawn(AutoReconnect)


-- ANIMATIONS
local RodIdle = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("ReelingIdle")
local RodShake = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("RodThrow")
local character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
local RodShake = animator:LoadAnimation(RodShake)
local RodIdle = animator:LoadAnimation(RodIdle)


-- LOAD CONTROLLER
_G.RunService = game:GetService("RunService")
_G.ReplicatedStorage = game:GetService("ReplicatedStorage")
_G.FishingControllerPath = _G.ReplicatedStorage.Controllers.FishingController
_G.FishingController = require(_G.FishingControllerPath)

_G.AutoFishingControllerPath = _G.ReplicatedStorage.Controllers.AutoFishingController
_G.AutoFishingController = require(_G.AutoFishingControllerPath)
_G.Replion = require(_G.ReplicatedStorage.Packages.Replion)


-- STATE
_G.AutoFishState = {
    IsActive = false,
    MinigameActive = false
}

_G.SPEED_LEGIT = 0.5


function _G.performClick()
    _G.FishingController:RequestFishingMinigameClick()
    task.wait(tonumber(_G.SPEED_LEGIT))
end


-- HOOK AUTO FISHING VISUAL
_G.originalAutoFishingStateChanged = _G.AutoFishingController.AutoFishingStateChanged
function _G.forceActiveVisual(arg1)
    _G.originalAutoFishingStateChanged(true)
end
_G.AutoFishingController.AutoFishingStateChanged = _G.forceActiveVisual


-- SERVER FORCE ENABLE
function _G.ensureServerAutoFishingOn()
    local replionData = _G.Replion.Client:WaitReplion("Data")
    local currentAutoFishingState = replionData:GetExpect("AutoFishing")

    if not currentAutoFishingState then
        local remoteFunctionName = "UpdateAutoFishingState"
        local Net = require(_G.ReplicatedStorage.Packages.Net)
        local UpdateAutoFishingRemote = Net:RemoteFunction(remoteFunctionName)

        pcall(function()
            UpdateAutoFishingRemote:InvokeServer(true)
        end)
    end
end


---------------------------------------------------
-- HOOK MINIGAME AUTO CLICK
---------------------------------------------------

_G.originalRodStarted = _G.FishingController.FishingRodStarted
_G.originalFishingStopped = _G.FishingController.FishingStopped
_G.clickThread = nil

_G.FishingController.FishingRodStarted = function(self, arg1, arg2)
    _G.originalRodStarted(self, arg1, arg2)

    if _G.AutoFishState.IsActive and not _G.AutoFishState.MinigameActive then
        
        _G.AutoFishState.MinigameActive = true

        if _G.clickThread then
            task.cancel(_G.clickThread)
        end

        _G.clickThread = task.spawn(function()
            while _G.AutoFishState.IsActive and _G.AutoFishState.MinigameActive do
                _G.performClick()
            end
        end)
    end
end

_G.FishingController.FishingStopped = function(self, arg1)
    _G.originalFishingStopped(self, arg1)

    if _G.AutoFishState.MinigameActive then
        _G.AutoFishState.MinigameActive = false
        task.wait(1)
        _G.ensureServerAutoFishingOn()
    end
end

function _G.ToggleAutoClick(state)
    _G.AutoFishState.IsActive = state

    if state then
        _G.ensureServerAutoFishingOn()
    else
        if _G.clickThread then
            task.cancel(_G.clickThread)
            _G.clickThread = nil
        end
        _G.AutoFishState.MinigameActive = false
    end
end

_G.FishSec = Legit:Section({
    Title = "Auto Fishing",
    TextSize = 22,
    TextXAlignment = "Center",
    Opened = true
})

---------------------------------------------------
-- UI: SPEED INPUT
---------------------------------------------------
_G.RecastCD = _G.FishSec:Input({
    Title = "Speed Legit",
    Desc = "Speed Click for Auto Fish Legit",
    Value = _G.SPEED_LEGIT,
    Placeholder = "Input Speed..",
    Callback = function(input)
        local number = tonumber(input)
        if number then
            _G.SPEED_LEGIT = number
        end
    end
})

---------------------------------------------------
-- UI: TOGGLE AUTO FISH LEGIT
---------------------------------------------------
_G.FishSec:Toggle({
    Title = "Auto Fish Legit",
    Value = false,
    Callback = function(state)

    -- UPDATE STATE LOCAL KE SCRIPT
    _G.ToggleAutoClick(state)

    -----------------------------------------
    -- üî• AUTO EQUIP / AUTO UNEQUIP ROD
    -----------------------------------------

    local netPath = game:GetService("ReplicatedStorage")
        :WaitForChild("Packages")
        :WaitForChild("_Index")
        :WaitForChild("sleitnick_net@0.2.0")
        :WaitForChild("net")

    local Equip = netPath:WaitForChild("RE/EquipToolFromHotbar")
    local Unequip = netPath:WaitForChild("RE/UnequipToolFromHotbar")
    local UpdateState = netPath:WaitForChild("RF/UpdateAutoFishingState")

    if state then
        -----------------------------------------
        -- ‚õèÔ∏è AUTO EQUIP
        -----------------------------------------
        pcall(function()
            Equip:FireServer(1) -- 1 = slot rod
        end)

        -- AUTO FISHING SERVER FORCE ENABLE
        pcall(function()
            UpdateState:InvokeServer(true)
        end)

    else
        -----------------------------------------
        -- üö´ AUTO UNEQUIP + AUTO FISHING OFF
        -----------------------------------------
        pcall(function()
            UpdateState:InvokeServer(false)
        end)

        pcall(function()
            Unequip:FireServer()
        end)

    end


    -----------------------------------------
    -- HIDE/SHOW MINIGAME GUI
    -----------------------------------------
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local fishingGui = playerGui:WaitForChild("Fishing").Main
    local chargeGui = playerGui:WaitForChild("Charge").Main

    fishingGui.Visible = not state
    chargeGui.Visible = not state
end

})

_G.FishSec = Legit:Section({
    Title = "Lock position",
    TextSize = 22,
    Opened = true
})


local LockEnabled = false
local SavedCFrame = nil

_G.FishSec:Toggle({
    Title = "Enable Lock Position",
    Desc= "Turn ON Before Use Legit Fishing",
    Value = false,

    Callback = function(state)
        LockEnabled = state

        -- pastikan player & character siap
        local Players = game:GetService("Players")
        local lp = Players.LocalPlayer
        if not lp then return end

        local char = lp.Character or lp.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart", 1)

        if state then
            if hrp then
                SavedCFrame = hrp.CFrame
            end

            -- loop lock posisi
            task.spawn(function()
                while LockEnabled do
                    task.wait()

                    local c = lp.Character
                    local h = c and c:FindFirstChild("HumanoidRootPart")

                    if h and SavedCFrame then
                        h.CFrame = SavedCFrame
                    end
                end
            end)
        end
    end
})


---------------------------------------------------
-- END: Fitur Legit Auto Fishing
---------------------------------------------------
local FishingSection = Window:Section({ Title = "Instant Fishing", Opened = true })
local FishingTab = FishingSection:Tab({ Title = "Instant Fishing", Icon = "fish", ShowTabTitle = true })

---------------------------------------------------
-- üîß Instant Fishing
---------------------------------------------------
FishingTab:Section({ Title = "Instant Fish Settings", Opened = true })

---------------------------------------------------
-- üîß Variabel & Remote
---------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Net = ReplicatedStorage:WaitForChild("Packages")
    :WaitForChild("_Index")["sleitnick_net@0.2.0"].net

local REReplicateTextEffect = Net["RE/ReplicateTextEffect"]
local REFishingCompleted = Net["RE/FishingCompleted"]

local AutoFishing = false
local fishingLoop = nil
local gotFishUUID = false
local currentUUID = nil

-- üïì Delay Config (default)
local CompleteDelay = 1.4
local ResetTimer = 0 -- ‚õî reset timer jadi 0 (tanpa delay)

---------------------------------------------------
-- ‚öôÔ∏è UI Slider (format WindUI terbaru)
---------------------------------------------------
local CompleteDelaySlider = FishingTab:Slider({
    Title = "Delay hatch",
     Desc= "Delay Hatch fish",
    Step = 0.1,
    Value = {
        Min = 0.1,
        Max = 5,
        Default = 1.4,
    },
    Callback = function(value)
        CompleteDelay = value
        print("[‚öôÔ∏è AVholker] Complete Delay diatur ke:", value)
    end
})

-- ‚õî SLIDER ResetTimer DIHAPUS

---------------------------------------------------
-- üß© Deteksi UUID Ikan (Tanda "!" Muncul)
---------------------------------------------------
REReplicateTextEffect.OnClientEvent:Connect(function(data)
    if not AutoFishing then return end
    if not data or not data.UUID then return end

    if data.TextData and data.TextData.EffectType == "Exclaim" then
        currentUUID = data.UUID
        gotFishUUID = true
        print("[üé£ AVholker] UUID ikan terdeteksi:", currentUUID)
    end
end)

---------------------------------------------------
-- üé£ AUTO EQUIP ROD
---------------------------------------------------
local AutoEquipRodEnabled = false

local ToggleAutoEquipRod = FishingTab:Toggle({
    Title = "üé£ Auto Equip Rod",
    Desc = "Auto equip/unequip rod",
    Icon = "box",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        AutoEquipRodEnabled = state
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Net = ReplicatedStorage:WaitForChild("Packages")
            :WaitForChild("_Index")["sleitnick_net@0.2.0"].net

        if state then
            -- üîπ Equip Rod
            local args = {1}
            Net["RE/EquipToolFromHotbar"]:FireServer(unpack(args))
            print("[üé£ AVholker] Auto Equip Rod: ON ‚Üí Rod dipakai.")

            -- üîí Cegah manual unequip selama toggle aktif
            local player = game.Players.LocalPlayer
            local char = player.Character or player.CharacterAdded:Wait()
            local hum = char:WaitForChild("Humanoid")

            hum.UnequipTools = function()
                if AutoEquipRodEnabled then
                    print("[üö´ AVholker] Tidak bisa unequip selama Auto Equip aktif.")
                    return
                end
            end

        else
            -- üîπ Unequip Rod lewat Remote
            Net["RE/UnequipToolFromHotbar"]:FireServer()
            print("[üé£ AVholker] Auto Equip Rod: OFF ‚Üí Rod dilepas.")
        end
    end
})

---------------------------------------------------
-- üîÑ AUTO FISH LOOP
---------------------------------------------------
local ToggleAutoFish = FishingTab:Toggle({
    Title = "Enable Auto Fishing",
    Desc = "Aktifkan otomatis memancing berulang",
    Icon = "fish",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        AutoFishing = state

        if AutoFishing then
            fishingLoop = task.spawn(function()
                while AutoFishing do
                    gotFishUUID = false
                    currentUUID = nil

                    ---------------------------------------------------
                    -- ü™ù STEP 1: ChargeFishingRod (NO ANIMASI)
                    ---------------------------------------------------
                    local step1_args = {1759980098.06865}
                    Net["RF/ChargeFishingRod"]:InvokeServer(unpack(step1_args))
                    print("[Step 1] ChargeFishingRod done.")
                    task.wait()

                    ---------------------------------------------------
                    -- üéØ STEP 2: RequestFishingMinigameStarted
                    ---------------------------------------------------
                    local step2_args = {
                        -0.5718746185302734,
                        0.999755886319293,
                        1761964263.251308
                    }
                    Net["RF/RequestFishingMinigameStarted"]:InvokeServer(unpack(step2_args))
                    print("[Step 2] RequestFishingMinigameStarted done.")

                    ---------------------------------------------------
                    -- üïì WAIT UUID (NO ANIMATION)
                    ---------------------------------------------------
                    local timeout = 0
                    local t0 = tick()
                    while not gotFishUUID and (tick() - t0) < timeout and AutoFishing do
                        task.wait()
                    end

                    ---------------------------------------------------
                    -- üé£ STEP 3: FishingCompleted via UUID
                    ---------------------------------------------------
                    if gotFishUUID and currentUUID then
                        print(string.format("[Step 3] UUID: %s ‚Üí FishingCompleted (delay %.1fs)...",
                            currentUUID, CompleteDelay))
                        task.wait(CompleteDelay)
                        REFishingCompleted:FireServer()
                    else
                        print("[Step 3] UUID tidak terdeteksi ‚Üí langsung FishingCompleted.")
                        REFishingCompleted:FireServer()
                    end

                    ---------------------------------------------------
                    -- üîÅ RESET TIMER TANPA DELAY (task.wait())
                    ---------------------------------------------------
                    task.wait(1.5) -- ‚õî tidak ada delay (0)
                end
            end)
        else
            if fishingLoop then
                task.cancel(fishingLoop)
            end
        end
    end
})

-- ================================
-- INSERT: Auto Fish V2 Section (below Auto Fish X5 Speed)
-- Entire Auto Fish V2 system included with V2-prefixed config names to avoid conflicts
-- ================================
-- Create a new section in the existing Fish Menu (FishingTab) for Auto Fish V2
FishingTab:Section({ Title = "Auto Fish V2", Opened = true })

-- V2-specific config/state (renamed to avoid collisions)
local V2Config = {
    FishingV2 = false,
    PerfectCatch = false,
}

local FishingV2State = {
    Enabled = false,
    Active = false,
    DetectedRod = nil,
    RodDelay = 2.0,
    DelayInitialized = false,
}

local RodDelays = {
    ["Bamboo Rod"] = 1.12, ["Element Rod"] = 1.12, ["Ares Rod"] = 1.45,
    ["Angler Rod"] = 1.45, ["Ghostfinn Rod"] = 1.45, ["Astral Rod"] = 1.9,
    ["Chrome Rod"] = 2.3, ["Steampunk Rod"] = 2.5, ["Lucky Rod"] = 3.5,
    ["Midnight Rod"] = 3.3, ["Demascus Rod"] = 3.9, ["Grass Rod"] = 3.8,
    ["Luck Rod"] = 4.2, ["Carbon Rod"] = 4.0, ["Lava Rod"] = 4.2, ["Starter Rod"] = 4.3,
}


local QuestConfig_V2 = { Active = false, CurrentQuest = nil, SelectedTask = nil, CurrentLocation = nil, Teleported = false, Fishing = false, LastTaskIndex = nil }

local RemoteReferences = {} -- local to V2 block
local obtainedFishUUIDs = {}

-- SetupRemoteReferences for V2 uses safeFindNetFolder if available
local function SetupRemoteReferencesV2()
    local ok, err = pcall(function()
        local netFolder = nil
        -- prefer safeFindNetFolder if present
        if type(safeFindNetFolder) == "function" then
            netFolder = safeFindNetFolder()
        end
        if not netFolder then
            -- fallback to original lookup
            local pk = ReplicatedStorage:FindFirstChild("Packages")
            if not pk then error("Packages not found") end
            local idx = pk:FindFirstChild("_Index")
            if not idx then error("_Index not found") end
            local exact = idx:FindFirstChild("sleitnick_net@0.2.0")
            if exact and exact:FindFirstChild("net") then netFolder = exact:FindFirstChild("net") end
            if not netFolder then
                for _, v in ipairs(idx:GetChildren()) do
                    if v:FindFirstChild("net") then netFolder = v:FindFirstChild("net"); break end
                end
            end
        end
        if not netFolder then error("net folder not found") end
        RemoteReferences.Net = netFolder
        RemoteReferences.ChargeRod = RemoteReferences.Net:WaitForChild("RF/ChargeFishingRod")
        RemoteReferences.RodRemote = RemoteReferences.Net:WaitForChild("RF/ChargeFishingRod")
        RemoteReferences.MiniGameRemote = RemoteReferences.Net:WaitForChild("RF/RequestFishingMinigameStarted")
        RemoteReferences.StartMini = RemoteReferences.Net:WaitForChild("RF/RequestFishingMinigameStarted")
        RemoteReferences.FinishRemote = RemoteReferences.Net:WaitForChild("RE/FishingCompleted")
        -- not all games have all remotes; pcall around optional ones
        pcall(function() RemoteReferences.UpdateAutoFishing = RemoteReferences.Net:WaitForChild("RF/UpdateAutoFishingState") end)
        pcall(function() RemoteReferences.EquipRemote = RemoteReferences.Net:WaitForChild("RE/EquipToolFromHotbar") end)
        pcall(function() RemoteReferences.ObtainedNewFishNotification = RemoteReferences.Net:WaitForChild("RE/ObtainedNewFishNotification") end)
    end)
    return ok
end

-- V2 Notify: reuse WindUI:Notify if available
local function NotifyV2(opts)
    if WindUI and WindUI.Notify then
        pcall(function()
            WindUI:Notify({
                Title = opts.Title or "Notice",
                Content = opts.Content or "",
                Duration = opts.Duration or 3,
                Icon = opts.Icon or "fish",
            })
        end)
    end
end

-- Auto Fishing V1 (V2 package included)
local FishingActiveV1 = false
local function StartFishingV1_V2()
    if FishingActiveV1 then return end
    FishingActiveV1 = true
    V2Config.FishingV1 = true

    pcall(function()
        if RemoteReferences.UpdateAutoFishing then
            RemoteReferences.UpdateAutoFishing:InvokeServer(true)
        end
    end)

    if V2Config.PerfectCatch then
        local mt = getrawmetatable(game)
        if mt then
            setreadonly(mt, false)
            local orig = mt.__namecall
            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                if method == "InvokeServer" and self == RemoteReferences.StartMini and V2Config.FishingV1 then
                    return orig(self, -1.233184814453125, 0.9945034885633273)
                end
                return orig(self, ...)
            end)
            setreadonly(mt, true)
        end
    end

    NotifyV2({ Title = "üé£ FISHING V1 STARTED", Content = "Game Auto System Activated!", Duration = 4 })

    task.spawn(function()
        while V2Config.FishingV1 do task.wait(1) end
        pcall(function()
            if RemoteReferences.UpdateAutoFishing then
                RemoteReferences.UpdateAutoFishing:InvokeServer(false)
            end
        end)
        FishingActiveV1 = false
    end)
end

local function StopFishingV1_V2()
    V2Config.FishingV1 = false
end

-- Detect equipped rod (V2)
local function DetectEquippedRod()
    local success, rodName = pcall(function()
        local backpackGui = player.PlayerGui:FindFirstChild("Backpack")
        if not backpackGui then return nil end
        local display = backpackGui:FindFirstChild("Display")
        if not display then return nil end
        for _, tile in ipairs(display:GetChildren()) do
            local ok, itemNamePath = pcall(function() return tile.Inner and tile.Inner.Tags and tile.Inner.Tags.ItemName end)
            if ok and itemNamePath and itemNamePath:IsA("TextLabel") then
                local name = itemNamePath.Text
                if RodDelays[name] then return name end
            end
        end
        return nil
    end)
    if success and rodName then return rodName end
    return nil
end

local function UpdateRodDelay(showNotify)
    if FishingV2State.DelayInitialized then return end
    local rodName = DetectEquippedRod()
    if rodName and RodDelays[rodName] then
        FishingV2State.DetectedRod = rodName
        FishingV2State.RodDelay = RodDelays[rodName]
        FishingV2State.DelayInitialized = true
        if showNotify then NotifyV2({ Title = "üé£ Rod Detected", Content = "Using: " .. rodName, Duration = 3 }) end
    else
        FishingV2State.DetectedRod = "Unknown Rod"
        FishingV2State.RodDelay = 2.0
        FishingV2State.DelayInitialized = true
        if showNotify then NotifyV2({ Title = "‚ö†Ô∏è Rod Detection Failed", Content = "Using default delay: 2.0s", Duration = 3 }) end
    end
end

local function SetupRodWatcher()
    pcall(function()
        local backpackGui = player.PlayerGui:WaitForChild("Backpack", 5)
        if not backpackGui then return end
        local display = backpackGui:WaitForChild("Display", 5)
        if not display then return end
        display.ChildAdded:Connect(function()
            task.wait(0.1)
            if FishingV2State.Enabled and not FishingV2State.DelayInitialized then UpdateRodDelay(true) end
        end)
    end)
end
task.spawn(SetupRodWatcher)

local function FishingV2Loop()
    while FishingV2State.Enabled do
        local ok, err = pcall(function()
            if RemoteReferences.EquipRemote then RemoteReferences.EquipRemote:FireServer(1) end
            if RemoteReferences.RodRemote then RemoteReferences.RodRemote:InvokeServer(tick()) end
            if RemoteReferences.MiniGameRemote then
                local baseX, baseY = -0.7499996, 1
                local x = baseX + (math.random(-500,500) / 10000000)
                local y = baseY + (math.random(-500,500) / 10000000)
                RemoteReferences.MiniGameRemote:InvokeServer(x, y)
            end
            task.wait(FishingV2State.RodDelay or 2.0)
            if RemoteReferences.FinishRemote then RemoteReferences.FinishRemote:FireServer() end
            task.wait(0.1)
        end)
        if not ok then warn("[V2 ERROR] "..tostring(err)); task.wait(2) end
    end
end

local function StartFishingV2()
    if FishingV2State.Enabled then warn("‚ö†Ô∏è Fishing V2 sudah aktif!"); return end
    -- ensure remotes are set
    pcall(function() SetupRemoteReferencesV2() end)
    FishingV2State.Enabled = true
    FishingV2State.DelayInitialized = false
    UpdateRodDelay(true)
    task.spawn(FishingV2Loop)
    NotifyV2({ Title = "üé£ FISHING V2 STARTED", Content = "Smart fishing running", Duration = 3 })
end

local function StopFishingV2()
    FishingV2State.Enabled = false
    FishingV2State.Active = false
    FishingV2State.DelayInitialized = false
    NotifyV2({ Title = "üõë FISHING V2 STOPPED", Content = "Auto Fishing V2 dihentikan", Duration = 3 })
end

-- Add UI controls for V2 inside the same Fish Menu
-- Toggle to enable/disable Fishing V2
local autoFishV2Toggle = FishingTab:Toggle({
    Title = "Enable AutoFish V2",
    Desc = "Smart Auto Fishing (V2) ‚Äî detects rod and automates mini-game.",
    Value = false,
    Callback = function(state)
        if state then
            -- ensure remotes are loaded
            local ok = SetupRemoteReferencesV2()
            if not ok then
                warn("[AutoFish V2] Failed to locate remote functions. V2 may not work.")
            end
            StartFishingV2()
        else
            StopFishingV2()
        end
    end
})

-- Extra optional UI: Button to Detect rod now
FishingTab:Button({
    Title = "Detect Equipped Rod (V2)",
    Desc = "Force-detect currently equipped rod for V2 timing.",
    Callback = function()
        UpdateRodDelay(true)
    end
})


-- =============================================
--  QUEST SYSTEM (WindUI) - Terintegrasi Auto Fish Legit
-- =============================================

-- Dependencies (jika sudah ada di atas, tidak masalah dideklarasi ulang lokal)
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer

-- Notifikasi helper (mengganti Rayfield:Notify)
local function Notify(title, content, duration)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title or "Info",
            Text = content or "",
            Duration = duration or 4
        })
    end)
end

-- Quest config & data
local QuestConfig = {
    Active = false,
    CurrentQuest = nil,
    SelectedTask = nil,
    CurrentLocation = nil,
    Teleported = false,
    Fishing = false,
    LastProgress = 0,
    LastTaskIndex = nil
}

local QuestData = {
    Tasks = {
        ["Catch a SECRET Crystal Crab"] = "CRYSTAL_CRAB",
        ["Catch 100 Epic Fish"] = "CRYSTAL_CRAB",
        ["Catch 10,000 Fish"] = "CRYSTAL_CRAB",
        ["Catch 300 Rare/Epic fish"] = "RARE_EPIC_FISH",
        ["Earn 1M Coins"] = "FARM_COINS",
        ["Catch 1 SECRET fish at Sisyphus"] = "SECRET_SYPUSH",
        ["Catch 3 Mythic fishes at Sisyphus"] = "SECRET_SYPUSH",
        ["Create 3 Transcended Stones"] = "CREATE_STONES",
        ["Catch 1 SECRET fish at Sacred Temple"] = "SECRET_TEMPLE",
        ["Catch 1 SECRET fish at Ancient Jungle"] = "SECRET_JUNGLE"
    },

    Locations = {
        ["CRYSTAL_CRAB"] = CFrame.new(40.0956, 1.7772, 2757.2583),
        ["RARE_EPIC_FISH"] = CFrame.new(-3596.9094, -281.1832, -1645.1220),
        ["SECRET_SYPUSH"] = CFrame.new(-3658.5747, -138.4813, -951.7969),
        ["SECRET_TEMPLE"] = CFrame.new(1451.4100, -22.1250, -635.6500),
        ["SECRET_JUNGLE"] = CFrame.new(1479.6647, 11.1430, -297.9549),
        ["FARM_COINS"] = CFrame.new(-553.3464, 17.1376, 114.2622)
    }
}

-- Helper: cari tracker quest di workspace (menu rings)
local function GetQuestTracker(questName)
    local menu = Workspace:FindFirstChild("!!! MENU RINGS")
    if not menu then return nil end

    for _, instance in ipairs(menu:GetChildren()) do
        if instance.Name:find("Tracker") and instance.Name:lower():find(questName:lower()) then
            return instance
        end
    end
    return nil
end

local function GetQuestProgress(questName)
    local tracker = GetQuestTracker(questName)
    if not tracker then return 0 end

    local label = tracker:FindFirstChild("Board") and tracker.Board:FindFirstChild("Gui")
        and tracker.Board.Gui:FindFirstChild("Content")
        and tracker.Board.Gui.Content:FindFirstChild("Progress")
        and tracker.Board.Gui.Content.Progress:FindFirstChild("ProgressLabel")

    if label and label:IsA("TextLabel") then
        local percent = string.match(label.Text, "([%d%.]+)%%")
        return tonumber(percent) or 0
    end
    return 0
end

local function GetAllTasks(questName)
    local tracker = GetQuestTracker(questName)
    if not tracker then return {} end

    local content = tracker:FindFirstChild("Board") and tracker.Board:FindFirstChild("Gui") and tracker.Board.Gui:FindFirstChild("Content")
    if not content then return {} end

    local tasks = {}
    for _, object in ipairs(content:GetChildren()) do
        if object:IsA("TextLabel") and object.Name:match("Label") and not object.Name:find("Progress") then
            local text = object.Text
            local percent = string.match(text, "([%d%.]+)%%") or "0"
            local completed = text:find("100%%") or text:find("DONE") or text:find("COMPLETED")
            table.insert(tasks, {
                name = text,
                percent = tonumber(percent),
                completed = completed ~= nil
            })
        end
    end
    return tasks
end

local function GetActiveTasks(questName)
    local allTasks = GetAllTasks(questName)
    local activeTasks = {}

    for _, task in ipairs(allTasks) do
        if not task.completed then
            table.insert(activeTasks, task)
        end
    end
    return activeTasks
end

local function FindLocationByTaskName(taskName)
    for key, v in pairs(QuestData.Tasks) do
        if string.find(taskName, key, 1, true) then
            return v
        end
    end
    return nil
end

local function TeleportToQuestLocation(locationName)
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    if not character then return false end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end

    local cframe = QuestData.Locations[locationName]
    if cframe then
        humanoidRootPart.CFrame = cframe
        return true
    end
    return false
end

-- Integrasi dengan Auto Fish Legit: gunakan _G.ToggleAutoClick(true/false)
local function StartAutoFishForQuest()
    pcall(function()
        if _G and type(_G.ToggleAutoClick) == "function" then
            _G.ToggleAutoClick(true)
        end
    end)
end

local function StopAutoFishForQuest()
    pcall(function()
        if _G and type(_G.ToggleAutoClick) == "function" then
            _G.ToggleAutoClick(false)
        end
    end)
end

-- Task loop: cek quest & jalankan auto fish jika perlu
task.spawn(function()
    while task.wait(1) do
        if not QuestConfig.Active then
            -- pastikan auto fish off saat tidak aktif (tidak memaksa user)
            -- (tidak memanggil StopAutoFishForQuest() di sini supaya tidak mengganggu pengguna lain)
            continue
        end

        local qname = QuestConfig.CurrentQuest
        if not qname then
            QuestConfig.Active = false
            continue
        end

        local questProgress = GetQuestProgress(qname)
        local activeTasks = GetActiveTasks(qname)
        local allTasks = GetAllTasks(qname)

        -- cek semua task selesai
        local allTasksCompleted = true
        for _, taskEntry in ipairs(allTasks) do
            if not taskEntry.completed and (not taskEntry.percent or taskEntry.percent < 100) then
                allTasksCompleted = false
                break
            end
        end

        if allTasksCompleted and questProgress >= 100 then
            -- selesai
            StopAutoFishForQuest()
            QuestConfig.Active = false
            Notify("QUEST COMPLETED", "All tasks finished for " .. tostring(qname), 5)
            continue
        end

        if #activeTasks == 0 then
            StopAutoFishForQuest()
            QuestConfig.Active = false
            continue
        end

        -- pilih current task
        local currentTask = nil
        local currentTaskIndex = nil

        for index, t in ipairs(activeTasks) do
            if QuestConfig.SelectedTask and t.name == QuestConfig.SelectedTask then
                currentTask = t
                currentTaskIndex = index
                break
            end
        end

        if not currentTask then
            if QuestConfig.LastTaskIndex and QuestConfig.LastTaskIndex <= #activeTasks then
                currentTaskIndex = QuestConfig.LastTaskIndex
                currentTask = activeTasks[currentTaskIndex]
            else
                currentTaskIndex = 1
                currentTask = activeTasks[1]
            end

            if currentTask then
                QuestConfig.SelectedTask = currentTask.name
                QuestConfig.LastTaskIndex = currentTaskIndex
                Notify("NEW TASK STARTED", (currentTask.name or "Unknown") .. " - " .. string.format("%.1f%%", currentTask.percent or 0), 4)
            end
        end

        if not currentTask then
            -- reset if tidak ada task
            QuestConfig.SelectedTask = nil
            QuestConfig.LastTaskIndex = nil
            QuestConfig.CurrentLocation = nil
            QuestConfig.Teleported = false
            QuestConfig.Fishing = false
            continue
        end

        -- jika task sudah 100% namun flag fishing false -> pindah ke task berikutnya
        if currentTask.percent and currentTask.percent >= 100 and not QuestConfig.Fishing then
            Notify("TASK COMPLETED", (currentTask.name or "Task") .. " - 100% FINISHED", 3)
            if currentTaskIndex and currentTaskIndex < #activeTasks then
                QuestConfig.LastTaskIndex = currentTaskIndex + 1
            else
                QuestConfig.LastTaskIndex = 1
            end
            QuestConfig.SelectedTask = nil
            QuestConfig.CurrentLocation = nil
            QuestConfig.Teleported = false
            QuestConfig.Fishing = false
            continue
        end

        -- cari lokasi untuk task saat ini
        if not QuestConfig.CurrentLocation then
            QuestConfig.CurrentLocation = FindLocationByTaskName(currentTask.name)
            if not QuestConfig.CurrentLocation then
                -- tidak menemukan lokasi cocok -> skip task
                QuestConfig.SelectedTask = nil
                continue
            end
        end

        -- teleport jika belum
        if not QuestConfig.Teleported then
            if TeleportToQuestLocation(QuestConfig.CurrentLocation) then
                QuestConfig.Teleported = true
                task.wait(1.5)
            end
            continue
        end

        -- mulai auto fishing jika belum
        if not QuestConfig.Fishing then
            StartAutoFishForQuest()
            QuestConfig.Fishing = true
            Notify("QUEST FARMING STARTED", "Auto fishing for: " .. (currentTask.name or "Task"), 3)
        end

        -- jika progress meningkat cukup, simpan LastProgress
        local newProgress = GetQuestProgress(qname)
        if newProgress and newProgress > (QuestConfig.LastProgress or 0) then
            QuestConfig.LastProgress = newProgress
        end
    end
end)

-- ===========================
--  UI: QUEST TAB (WindUI)
-- ===========================
local QuestTab = FishingSection:Tab({
    Title = "Quest System",
    Icon = "book-open",
    ShowTabTitle = true,
})

local QuestSection = QuestTab:Section({
    Title = "Auto Quest System",
    TextSize = 20,
    Opened = true
})

-- contoh daftar quest sesuai kode lama (nama internal => display)
local quests = {
    {Name = "Aura", Display = "Aura"},
    {Name = "Deep Sea", Display = "Deep Sea"},
    {Name = "Element", Display = "Element"}
}

for _, quest in ipairs(quests) do
    local s = QuestTab:Section({
        Title = quest.Display .. " Quest",
        TextSize = 18,
        Opened = true
    })

s:Toggle({
    Title = "Auto " .. quest.Display,
    Value = false,
    Callback = function(val)
        if val then
            -- =====================================================
            -- QUEST ON
            -- =====================================================

            QuestConfig.Active = true
            QuestConfig.CurrentQuest = quest.Name
            QuestConfig.SelectedTask = nil
            QuestConfig.CurrentLocation = nil
            QuestConfig.Teleported = false
            QuestConfig.Fishing = false
            QuestConfig.LastProgress = GetQuestProgress(quest.Name)
            QuestConfig.LastTaskIndex = nil

            -----------------------------------------
            -- ‚úÖ AUTO EQUIP ROD (slot 1)
            -----------------------------------------
            pcall(function()
                local args = { 1 }
                game:GetService("ReplicatedStorage")
                    :WaitForChild("Packages")
                    :WaitForChild("_Index")
                    :WaitForChild("sleitnick_net@0.2.0")
                    :WaitForChild("net")
                    :WaitForChild("RE/EquipToolFromHotbar")
                    :FireServer(unpack(args))
            end)

            Notify("QUEST STARTED", "Auto quest activated for " .. quest.Display, 4)


        else
            -- =====================================================
            -- QUEST OFF
            -- =====================================================

            QuestConfig.Active = false

            -----------------------------------------
            -- ‚ùå MATIKAN AUTO FISHING SERVER
            -----------------------------------------
            pcall(function()
                local args = { false }
                game:GetService("ReplicatedStorage")
                    :WaitForChild("Packages")
                    :WaitForChild("_Index")
                    :WaitForChild("sleitnick_net@0.2.0")
                    :WaitForChild("net")
                    :WaitForChild("RF/UpdateAutoFishingState")
                    :InvokeServer(unpack(args))
            end)

            -----------------------------------------
            -- ‚ùå MATIKAN AUTO FISH LEGIT
            -----------------------------------------
            StopAutoFishForQuest()

            -----------------------------------------
            -- ‚ùå UNEQUIP ROD
            -----------------------------------------
            pcall(function()
                game:GetService("ReplicatedStorage")
                    :WaitForChild("Packages")
                    :WaitForChild("_Index")
                    :WaitForChild("sleitnick_net@0.2.0")
                    :WaitForChild("net")
                    :WaitForChild("RE/UnequipToolFromHotbar")
                    :FireServer()
            end)

            Notify("QUEST STOPPED", quest.Display .. " stopped", 3)
        end
    end
})


    s:Button({
        Title = "Check " .. quest.Display .. " Progress",
        Callback = function()
            local progress = GetQuestProgress(quest.Name)
            local activeTasks = GetActiveTasks(quest.Name)

            local message = quest.Display .. " Progress: " .. string.format("%.1f%%", progress) .. "\n"
            if #activeTasks == 0 then
                message = message .. "(No active tasks found)"
            else
                for index, task in ipairs(activeTasks) do
                    message = message .. string.format("- %s (%.1f%%)\n", task.name, task.percent or 0)
                end
            end

            Notify(quest.Display .. " Progress", message, 6)
        end
    })
end

-- ===========================
--  PARAGRAPH: AUTO UPDATE 5 DETIK
-- ===========================
local ParSection = QuestTab:Section({
    Title = "Quest Info",
    TextSize = 20,
    TextXAlignment = "Center",
    Opened = true,
})

local function BuildAllQuestText()
    local text = ""

    for _, quest in ipairs(quests) do
        local progress = GetQuestProgress(quest.Name)
        local activeTasks = GetActiveTasks(quest.Name)

        text = text .. string.format("üìå %s Quest ‚Äî %.1f%%\n", quest.Display, progress)

        if #activeTasks == 0 then
            text = text .. "   üèÜ All tasks completed\n\n"
        else
            for _, task in ipairs(activeTasks) do
                text = text .. string.format(
                    "   üé£ %s (%.1f%%)\n",
                    task.name,
                    task.percent or 0
                )
            end
            text = text .. "\n"
        end
    end

    return text
end

-- buat paragraf awal
local AllQuestParagraph = ParSection:Paragraph({
    Title = "All Quest Progress",
    Desc = BuildAllQuestText(),
    Color = "Grey",
    Locked = false,
})

-- auto update setiap 5 detik
task.spawn(function()
    while task.wait(5) do
        if AllQuestParagraph then
            AllQuestParagraph:Update({
                Desc = BuildAllQuestText()
            })
        end
    end
end)


-- ============================
-- AUTO SELL ONLY (CLEAN VERSION)
-- ============================

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer

if not player then
    warn("Player not found (script must run as LocalScript).")
end

-- Notif wrapper (WindUI)
local function Notify(opts)
    if WindUI and WindUI.Notify then
        pcall(function()
            WindUI:Notify({
                Title = opts.Title or "Notice",
                Content = opts.Content or "",
                Duration = opts.Duration or 3,
                Icon = opts.Icon or "wallet",
            })
        end)
    end
end

-- ============================
-- CONFIG
-- ============================
local Config = {
    AutoSell = false,
    SellThreshold = 4000,
}

-- Storage list utk UUID ikan yg baru didapat
local obtainedFishUUIDs = {}

-- ============================
-- REMOTE REFERENCES
-- ============================
local RemoteReferences = {
    Net = nil,
    SellRemote = nil,
    ObtainedNewFishNotification = nil,
}

local function SetupRemoteReferences()
    local ok = pcall(function()
        local pkg = ReplicatedStorage:WaitForChild("Packages")

        if pkg and pkg._Index then
            local net = pkg._Index["sleitnick_net@0.2.0"] and pkg._Index["sleitnick_net@0.2.0"].net
            if net then
                RemoteReferences.Net = net
                -- Sell remote
                pcall(function()
                    RemoteReferences.SellRemote =
                        net:FindFirstChild("RF/SellAllItems")
                        or net:FindFirstChild("RE/SellAllItems")
                end)
                -- Notification remote
                pcall(function()
                    RemoteReferences.ObtainedNewFishNotification =
                        net:FindFirstChild("RE/ObtainedNewFishNotification")
                end)
            end
        end

        -- Fallback
        if not RemoteReferences.ObtainedNewFishNotification then
            pcall(function()
                RemoteReferences.ObtainedNewFishNotification =
                    ReplicatedStorage:FindFirstChild("RE/ObtainedNewFishNotification")
            end)
        end
    end)

    if not ok then
        warn("Failed to setup remotes")
    end

    return ok
end

-- ============================
-- LISTENER: NOTIFICATION FISH BARU MASUK INVENTORY
-- (Auto favorite DIHAPUS)
-- ============================

local function SetupSimpleListener()
    local notif = RemoteReferences.ObtainedNewFishNotification
    if not notif then
        warn("‚úñ ObtainedNewFishNotification not found; Listener disabled")
        return false
    end

    notif.OnClientEvent:Connect(function(itemId, itemData, inventoryData)
        if inventoryData and inventoryData.InventoryItem then
            local invItem = inventoryData.InventoryItem
            local uuid = invItem.UUID
            if uuid then
                obtainedFishUUIDs[#obtainedFishUUIDs + 1] = uuid
            end
        end
    end)

    return true
end

-- ============================
-- AUTO SELL LOOP
-- ============================

task.spawn(function()
    while task.wait(1) do
        if Config.AutoSell and #obtainedFishUUIDs >= (Config.SellThreshold or 1) then
            Notify({
                Title = "üí∞ Auto Sell",
                Content = "Selling fish...",
                Duration = 3,
            })

            pcall(function()
                if RemoteReferences.SellRemote and RemoteReferences.SellRemote.InvokeServer then
                    RemoteReferences.SellRemote:InvokeServer()
                end
            end)

            obtainedFishUUIDs = {}
            task.wait(2)
        end
    end
end)

-- ============================
-- UI ‚Äî Auto Sell Only
-- ============================

local AutoSystemTab = Window:Tab({
    Title = "Auto Sell",
    Icon = "wallet",
    ShowTabTitle = true
})

AutoSystemTab:Section({ Title = "Auto Sell Settings" })

AutoSystemTab:Toggle({
    Title = "Enable Auto Sell While Fishing",
    Value = Config.AutoSell,
    Callback = function(v)
        Config.AutoSell = v
        Notify({
            Title = "Auto Sell",
            Content = v and "Enabled" or "Disabled",
            Duration = 2,
        })
    end,
})

AutoSystemTab:Input({
    Title = "Auto Sell Threshold (fish count)",
    Placeholder = tostring(Config.SellThreshold),
    Callback = function(text)
        local n = tonumber(text)
        if n then
            Config.SellThreshold = n
            Notify({
                Title = "Sell Threshold",
                Content = tostring(n),
                Duration = 2,
            })
        end
    end,
})

AutoSystemTab:Button({
    Title = "Sell Now",
    Callback = function()
        if RemoteReferences.SellRemote then
            pcall(function()
                RemoteReferences.SellRemote:InvokeServer()
            end)

            Notify({
                Title = "Auto Sell",
                Content = "Sold items (manual)",
                Duration = 2,
            })
        else
            Notify({
                Title = "Auto Sell",
                Content = "Sell remote not found",
                Duration = 2,
            })
        end
    end,
})

-- ============================
-- INIT
-- ============================

task.spawn(function()
    task.wait(0.25)
    SetupRemoteReferences()
    task.wait(0.25)
    SetupSimpleListener()
end)



-- =================== Tab Favorite Only ===================

local FG = Window:Tab({
    Title = "Auto Favorite",
    Icon = "star",
    ShowTabTitle = true
})
FG:Section({ Title = "Favorite V1" })
-- ============================
-- AUTO FAVORITE (WORKING CORE)
-- ============================

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
if not player then return end

---------------------------------------------------
-- CONFIG
---------------------------------------------------
local Config = {
    AutoFavorite = false,
    FavoriteCategories = { "Secret" },
}

---------------------------------------------------
-- REMOTES
---------------------------------------------------
local RemoteReferences = {}

local function SetupRemoteReferences()
    pcall(function()
        local pkg = ReplicatedStorage:WaitForChild("Packages")
        if pkg and pkg._Index then
            local net = pkg._Index["sleitnick_net@0.2.0"].net
            RemoteReferences.Net = net
            RemoteReferences.FavoriteRemote = net:FindFirstChild("RE/FavoriteItem")
            RemoteReferences.ObtainedNewFishNotification =
                net:FindFirstChild("RE/ObtainedNewFishNotification")
        end
    end)

    if not RemoteReferences.ObtainedNewFishNotification then
        RemoteReferences.ObtainedNewFishNotification =
            ReplicatedStorage:FindFirstChild("RE/ObtainedNewFishNotification")
    end
end

---------------------------------------------------
-- FAVORITE CHECK
---------------------------------------------------
local function ShouldFavorite(tier)
    for _, cat in ipairs(Config.FavoriteCategories) do
        if (cat == "Uncommon" and tier == 2)
        or (cat == "Legendary" and tier == 5)
        or (cat == "Mythic" and tier == 6)
        or (cat == "Secret" and tier == 7) then
            return true
        end
    end
    return false
end

---------------------------------------------------
-- LISTENER (DIAMBIL DARI SCRIPT WORKING)
---------------------------------------------------
local function SetupAutoFavoriteListener()
    local notif = RemoteReferences.ObtainedNewFishNotification
    if not notif then
        warn("ObtainedNewFishNotification not found")
        return
    end

    notif.OnClientEvent:Connect(function(itemId, itemData, inventoryData)
        local fishTier = 0
        local uuid
        local actualData

        -- üîë LOGIKA PENTING (INI YANG HILANG DI SCRIPT SEBELUMNYA)
        pcall(function()
            if type(itemData) == "table" and itemData.Name then
                actualData = itemData
            elseif typeof(itemData) == "Instance" and itemData:IsA("ModuleScript") then
                actualData = require(itemData)
            else
                local itemsFolder = ReplicatedStorage:FindFirstChild("Items")
                if itemsFolder then
                    for _, item in pairs(itemsFolder:GetChildren()) do
                        local ok, data = pcall(function()
                            return require(item)
                        end)
                        if ok and data and data.Data and data.Data.Id == itemId then
                            actualData = data.Data
                            break
                        end
                    end
                end
            end
        end)

        if actualData then
            fishTier = tonumber(actualData.Tier) or 0
        end

        if inventoryData and inventoryData.InventoryItem then
            uuid = inventoryData.InventoryItem.UUID
        end

        -- AUTO FAVORITE
        if Config.AutoFavorite
            and uuid
            and fishTier > 0
            and RemoteReferences.FavoriteRemote
            and ShouldFavorite(fishTier)
        then
            task.spawn(function()
                task.wait(0.3)
                pcall(function()
                    -- ‚ö†Ô∏è SENGAJA TANPA parameter kedua
                    -- karena SCRIPT ASLI YANG WORK JUGA BEGINI
                    RemoteReferences.FavoriteRemote:FireServer(uuid)
                end)
            end)
        end
    end)
end

---------------------------------------------------
-- UI
---------------------------------------------------

FG:Toggle({
    Title = "Enable Auto Favorite",
    Value = Config.AutoFavorite,
    Callback = function(v)
        Config.AutoFavorite = v
    end
})

FG:Dropdown({
    Title = "Favorite Categories",
    Values = { "Uncommon", "Legendary", "Mythic", "Secret" },
    Value = Config.FavoriteCategories,
    Multi = true,
    Callback = function(v)
        Config.FavoriteCategories = v
    end
})

---------------------------------------------------
-- INIT
---------------------------------------------------
task.spawn(function()
    task.wait(0.3)
    SetupRemoteReferences()
    task.wait(0.3)
    SetupAutoFavoriteListener()
end)

FG:Section({ Title = "Favorite V2" })


-- [[ Services ]]
local svc = {
    Players = game:GetService("Players"),
    RS = game:GetService("ReplicatedStorage"),
}

-- [[ Local Player + Hrp ]]
local player = svc.Players.LocalPlayer
local hrp = player.Character and player.Character:WaitForChild("HumanoidRootPart") 
    or player.CharacterAdded:Wait():WaitForChild("HumanoidRootPart")

-- [[ Require Modules ]]
local mods = {
    Net = svc.RS.Packages._Index["sleitnick_net@0.2.0"].net,
    Replion = require(svc.RS.Packages.Replion),
    ItemUtility = require(svc.RS.Shared.ItemUtility),
    Variants = require(svc.RS.Variants),
}

-- [[ Remote API ]]
local api = {
    Events = {
        REFav = mods.Net["RE/FavoriteItem"],
        REFavChg = mods.Net["RE/FavoriteStateChanged"],
    },
}

-- [[ Replion ]]
local repl = {
    Data = mods.Replion.Client:WaitReplion("Data"),
    Items = svc.RS:WaitForChild("Items"),
}

-- =================================================================
-- ======================  AUTO FAVORITE ONLY  ======================
-- =================================================================

-- [[ State ]]
local st = {
    autoFavEnabled = false,
    selectedName = {},
    selectedRarity = {},
    selectedVariant = {},
    strictMode = false,
}

-- [[ Load fish names ]]
local fishNames = {}
for _, module in ipairs(repl.Items:GetChildren()) do
    if module:IsA("ModuleScript") then
        local ok, data = pcall(require, module)
        if ok and data.Data and data.Data.Type == "Fish" then
            table.insert(fishNames, data.Data.Name)
        end
    end
end
table.sort(fishNames)

-- [[ Tier Mapping ]]
_G.TierFish = {
    [1] = "Common",
    [2] = "Uncommon",
    [3] = "Rare",
    [4] = "Epic",
    [5] = "Legendary",
    [6] = "Mythic",
    [7] = "Secret",
}

-- [[ Variants ]]
_G.Variant = {}
for name, _ in pairs(mods.Variants) do
    table.insert(_G.Variant, name)
end

-- Convert dropdown selection ‚Üí dictionary {["Fish Name"] = true}
function toSet(sel)
    local set = {}
    if type(sel) == "table" then
        for _, v in ipairs(sel) do
            set[v] = true
        end
        for k, v in pairs(sel) do
            if v == true then
                set[k] = true
            end
        end
    end
    return set
end

local favState = {}

api.Events.REFavChg.OnClientEvent:Connect(function(uuid, state)
    rawset(favState, uuid, state)
end)

function hasSelection(sel)
    return sel and next(sel) ~= nil
end

function isSelected(sel, key)
    return sel[key] == true
end

-- [[ Core Auto Favorite ]]
function checkAndFavorite(item)
    if not st.autoFavEnabled then return end

    local info = mods.ItemUtility.GetItemDataFromItemType("Items", item.Id)
    if not info or info.Data.Type ~= "Fish" then return end

    local rarity = _G.TierFish[info.Data.Tier]
    local name = info.Data.Name
    local variant = (item.Metadata and item.Metadata.VariantId) or "None"

    -- Has selections?
    local hasName = hasSelection(st.selectedName)
    local hasRarity = hasSelection(st.selectedRarity)
    local hasVariant = hasSelection(st.selectedVariant)

    if not (hasName or hasRarity or hasVariant) then return end

    local nameMatch = hasName and isSelected(st.selectedName, name)
    local rarityMatch = hasRarity and isSelected(st.selectedRarity, rarity)
    local variantMatch = hasVariant and isSelected(st.selectedVariant, variant)

    local shouldFav

    if st.strictMode then
        if hasVariant and not variantMatch then
            shouldFav = false
        else
            shouldFav = 
                (not hasName or nameMatch) and
                (not hasRarity or rarityMatch)
        end
    else
        shouldFav = 
            (hasName and nameMatch) or 
            (hasRarity and rarityMatch) or 
            (hasVariant and variantMatch)
    end

    local isFav = rawget(favState, item.UUID)
    if isFav == nil then isFav = item.Favorited end

    if shouldFav and not isFav then
        api.Events.REFav:FireServer(item.UUID)
        rawset(favState, item.UUID, true)
    end
end

function scanInventory()
    if not st.autoFavEnabled then return end
    for _, item in ipairs(repl.Data:GetExpect({ "Inventory", "Items" })) do
        checkAndFavorite(item)
    end
end


FG:Dropdown({
    Values = fishNames,
    Multi = true,
    Title = "Name",
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(o)
        st.selectedName = toSet(o)
    end,
})

FG:Dropdown({
    Values = { "Common","Uncommon","Rare","Epic","Legendary","Mythic","Secret" },
    Multi = true,
    Title = "Rarity",
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(o)
        st.selectedRarity = toSet(o)
    end,
})

FG:Dropdown({
    Values = _G.Variant,
    Multi = true,
    Title = "Variant",
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(o)
        st.selectedVariant = toSet(o)
    end,
})

FG:Dropdown({
    Values = { "Non-Strict", "Strict" },
    Multi = false,
    Title = "Mode",
    Callback = function(o)
        st.strictMode = (o == "Strict")
    end,
})

FG:Toggle({
    Title = "Auto Favorite",
    Default = false,
    Callback = function(s)
        st.autoFavEnabled = s
        if s then
            scanInventory()
            repl.Data:OnChange({ "Inventory", "Items" }, scanInventory)
        end
    end,
})

FG:Button({
    Title = "Unfavorite All Fish",
    Callback = function()
        for _, item in ipairs(repl.Data:GetExpect({ "Inventory", "Items" })) do
            local isFav = rawget(favState, item.UUID)
            if isFav == nil then isFav = item.Favorited end
            if isFav then
                api.Events.REFav:FireServer(item.UUID)
                rawset(favState, item.UUID, false)
            end
        end
    end,
})

-----Auto Enchant Feature

-- [[ Services ]]
local svc = {
	Players = game:GetService("Players"),
	RS = game:GetService("ReplicatedStorage"),
}

-- [[ Player ]]
local player = svc.Players.LocalPlayer
local hrp = player.Character and player.Character:WaitForChild("HumanoidRootPart")
	or player.CharacterAdded:Wait():WaitForChild("HumanoidRootPart")

-- [[ Required Modules ]]
local mods = {
	Net = svc.RS.Packages._Index["sleitnick_net@0.2.0"].net,
	Replion = require(svc.RS.Packages.Replion),
	ItemUtility = require(svc.RS.Shared.ItemUtility),
}

-- [[ Remotes (HANYA untuk Enchant) ]]
local api = {
	Events = {
		REEquip = mods.Net["RE/EquipToolFromHotbar"],
		REEquipItem = mods.Net["RE/EquipItem"],
		REAltar = mods.Net["RE/ActivateEnchantingAltar"],
		REAltar2 = mods.Net["RE/ActivateSecondEnchantingAltar"],
	},
}

-- [[ Replion Data ]]
local repl = {
	Data = mods.Replion.Client:WaitReplion("Data"),
	Items = svc.RS:WaitForChild("Items")
}

-- ============================================================
--                ENCHANT SYSTEM ONLY
-- ============================================================

-- Ambil Data Rod, Current Enchant, jumlah stone & UUID stone
function getData(stoneId)
	local rod, ench, stones, uuids = "None", "None", 0, {}
	local eq = repl.Data:Get("EquippedItems") or {}
	local rods = repl.Data:Get({ "Inventory", "Fishing Rods" }) or {}

	for _, equipUuid in pairs(eq) do
		for _, r in ipairs(rods) do
			if r.UUID == equipUuid then
				local d = mods.ItemUtility:GetItemData(r.Id)
				rod = (d and d.Data.Name) or "None"

				if r.Metadata and r.Metadata.EnchantId then
					local e = mods.ItemUtility:GetEnchantData(r.Metadata.EnchantId)
					ench = (e and e.Data.Name) or "None"
				end
			end
		end
	end

	for _, it in pairs(repl.Data:GetExpect({ "Inventory", "Items" })) do
		local d = mods.ItemUtility:GetItemData(it.Id)
		if d and d.Data.Type == "Enchant Stones" and it.Id == stoneId then
			stones += 1
			table.insert(uuids, it.UUID)
		end
	end

	return rod, ench, stones, uuids
end

-- Ambil semua enchant dari game
local EnchantNames = {}
local EnchantNameToId = {}

for _, m in ipairs(svc.RS.Enchants:GetChildren()) do
	if m:IsA("ModuleScript") then
		local ok, d = pcall(require, m)
		if ok and d.Data.Name and d.Data.Id then
			EnchantNameToId[d.Data.Name] = d.Data.Id
			table.insert(EnchantNames, d.Data.Name)
		end
	end
end

table.sort(EnchantNames)

-- State Enchant
local EnchState = {
	Running = false,
	TargetEnchantIds = {},
	Method = "Normal",
}

local Ench = Window:Tab({
    Title = "Enchant",
    Icon = "wand-sparkles",
    ShowTabTitle = true
})

-- Dropdown Target Enchant
Ench:Dropdown({
	Title = "Target Enchant",
	Values = EnchantNames,
	Multi = true,
	Callback = function(selected)
		table.clear(EnchState.TargetEnchantIds)
		for _, name in ipairs(selected) do
			local id = EnchantNameToId[name]
			if id then EnchState.TargetEnchantIds[id] = true end
		end
	end,
})

-- Dropdown Method
Ench:Dropdown({
	Title = "Enchant Method",
	Values = { "Normal", "Second", "Evolved" },
	Callback = function(v)
		EnchState.Method = v
	end,
})

-- Toggle Start Auto Enchant
Ench:Toggle({
	Title = "Auto Enchant Until Match",
	Default = false,
	Callback = function(state)
		EnchState.Running = state
		if not state then return end

		task.spawn(function()
			while EnchState.Running do
				-- Stone ID: Normal=10, Second=246, Evolved=558
				local stoneId = (EnchState.Method == "Second" and 246)
					or (EnchState.Method == "Evolved" and 558)
					or 10

				local rod, ench, stoneCount, uuids = getData(stoneId)

				if rod == "None" or stoneCount <= 0 then
					EnchState.Running = false
					break
				end

				-- Equip stone
				local slot, t0 = nil, tick()
				while not slot and tick() - t0 < 5 do
					for sl, id in pairs(repl.Data:Get("EquippedItems") or {}) do
						if id == uuids[1] then slot = sl end
					end
					if not slot then
						api.Events.REEquipItem:FireServer(uuids[1], "Enchant Stones")
					end
					task.wait(0.3)
				end
				if not slot then break end

				api.Events.REEquip:FireServer(slot)
				task.wait(0.2)

				if EnchState.Method == "Second" then
					api.Events.REAltar2:FireServer()
				else
					api.Events.REAltar:FireServer()
				end

				task.wait(1.2)
			end
		end)
	end,
})

-- [[ Teleport Function ]]
local function teleportTo(x, y, z)
	if hrp then
		hrp.CFrame = CFrame.new(x, y, z)
	end
end

-- =========================
--        TELEPORT
-- =========================

Ench:Button({
	Title = "Teleport ‚Üí Enchant Altar",
	Callback = function()
		teleportTo(3258, -1301, 1391)
	end,
})

Ench:Button({
	Title = "Teleport ‚Üí Second Enchant Altar",
	Callback = function()
		teleportTo(1479, 128, -605)
	end,
})


-- Listen Enchant Result
local EnchantEvent = mods.Net["RE/RollEnchant"]

EnchantEvent.OnClientEvent:Connect(function(_, enchantId)
	if not EnchState.Running then return end
	if EnchState.TargetEnchantIds[enchantId] then
		EnchState.Running = false
	end
end)
    
 -- SERVICES
-- ============================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
if not player then warn("Player not found (script must run as LocalScript).") end

local function Notify(opts)
    if WindUI and WindUI.Notify then
        pcall(function()
            WindUI:Notify({
                Title = opts.Title or "Notice",
                Content = opts.Content or "",
                Duration = opts.Duration or 3,
                Icon = opts.Icon or "wallet",
            })
        end)
    end
end

-- Webhook config from script 1 (moved in)
local WebhookConfig = {
    Enabled = false,
    Url = "",
    SelectedCategories = {"Secret","Mythic","Legendary"}
}

local RemoteReferences = {}
local obtainedFishUUIDs = {}

-- =======================================================
-- WEBHOOK HELPERS (moved from script 1)
-- =======================================================
local function FormatCurrency(amount)
    if not amount or amount <= 0 then return "$0" end
    if amount >= 1000000 then return string.format("$%.2fM", amount/1000000)
    elseif amount >= 1000 then return string.format("$%.2fK", amount/1000)
    else return "$"..math.floor(amount) end
end

local FishCategories = {
    ["Secret"] = {
        "Blob Shark", "Great Christmas Whale", "Frostborn Shark", "Great Whale",
        "Worm Fish", "Robot Kraken", "Giant Squid", "Ghost Worm Fish",
        "Ghost Shark", "Queen Crab", "Orca", "Crystal Crab",
        "Monster Shark", "Eerie Shark", "King Jelly", "Bone Whale",
        "Ancient Whale", "Mosasaur Shark", "Elshark Gran Maja",
        "Dead Zombie Shark", "Zombie Shark", "Megalodon", "Lochness Monster",
        "Zombie Megalodon"
    },
    ["Mythic"] = {
        "Gingerbread Shark", "Loving Shark", "King Crab", "Blob Fish",
        "Hermit Crab", "Luminous Fish", "Plasma Shark", "Crocodile",
        "Ancient Relic Crocodile", "Panther Eel", "Hybodus Shark",
        "Magma Shark", "Sharp One", "Mammoth Appafish",
        "Frankenstein Longsnapper", "Pumpkin Ray", "Dark Pumpkin Appafish", "Armor Catfish"
    },
    ["Legendary"] = {
        "Yellowfin Tuna", "Lake Sturgeon", "Ligned Cardinal Fish", "Saw Fish",
        "Abyss Seahorse", "Blueflame Ray", "Hammerhead Shark",
        "Hawks Turtle", "Manta Ray", "Loggerhead Turtle",
        "Prismy Seahorse", "Gingerbread Turtle", "Thresher Shark",
        "Dotted Stingray", "Strippled Seahorse", "Deep Sea Crab",
        "Ruby", "Temple Spokes Tuna", "Sacred Guardian Squid",
        "Manoai Statue Fish", "Pumpkin Carved Shark", "Wizard Stingray",
        "Crystal Salamander", "Pumpkin StoneTurtle"
    },
}

local function ShouldSendWebhook(fishName, fishTier)
    if not WebhookConfig.Enabled or #WebhookConfig.SelectedCategories == 0 then
        return false
    end

    if fishTier then
        if table.find(WebhookConfig.SelectedCategories, "Secret") and fishTier == 7 then
            return true
        elseif table.find(WebhookConfig.SelectedCategories, "Mythic") and fishTier == 6 then
            return true
        elseif table.find(WebhookConfig.SelectedCategories, "Legendary") and fishTier == 5 then
            return true
        end
    end

    if fishName and type(fishName) == "string" then
        for _, cat in ipairs(WebhookConfig.SelectedCategories) do
            local list = FishCategories and FishCategories[cat]
            if list then
                for _, name in ipairs(list) do
                    if name == fishName then
                        return true
                    end
                end
            end
        end
    end

    return false
end

local function SendWebhook(fishName, fishTier, sellPrice, rarity)
    if not WebhookConfig.Enabled or WebhookConfig.Url == "" then return end

    local success, err = pcall(function()
        local timestamp = DateTime.now():ToIsoDate()

        local embed = {{
            ["title"] = "üé£ Hey New Fish Caught!",
            ["color"] = 65280,
            ["fields"] = {
                { name = "Fish Name", value = fishName, inline = true },
                { name = "Tier", value = tostring(fishTier), inline = true },
                { name = "Rarity", value = rarity, inline = true },
                { name = "Sell Price", value = FormatCurrency(sellPrice), inline = true },
            },
            ["footer"] = { text = "AVholkers Script ‚Ä¢ "..timestamp },
            ["thumbnail"] = {
                url = "https://cdn.discordapp.com/attachments/1128833020023439502/1142635557613989948/Untitled_design.png"
            }
        }}

        local data = {
            embeds = embed,
            username = "AVholkers Webhook",
            avatar_url = "https://cdn.discordapp.com/attachments/1128833020023439502/1142635557613989948/Untitled_design.png"
        }

        local jsonData = HttpService:JSONEncode(data)
        local req = syn and syn.request or http_request or request

        req({
            Url = WebhookConfig.Url,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = jsonData
        })
    end)

    if not success then warn("Webhook error:", err) end
end

-- - adds webhook trigger (from script 1) WITHOUT changing existing logic
-- ============================
local function SetupSimpleListener()
    local notif = RemoteReferences.ObtainedNewFishNotification
    if not notif then
        pcall(function()
            local net = RemoteReferences.Net
            notif = (net and net:FindFirstChild("RE/ObtainedNewFishNotification")) or notif
        end)
    end
    if not notif then
        warn("‚úñ ObtainedNewFishNotification remote not found; Auto Favorite will not work")
        return false
    end

    notif.OnClientEvent:Connect(function(itemId, itemData, inventoryData)
        local fishName, fishTier, sellPrice, uuid, actualData = "Unknown Fish", 0, 0, nil, nil

        pcall(function()
            if type(itemData) == "table" and itemData.Name then actualData = itemData
            elseif typeof(itemData) == "Instance" and itemData:IsA("ModuleScript") then actualData = require(itemData)
            else
                local itemsFolder = ReplicatedStorage:FindFirstChild("Items")
                if itemsFolder then
                    for _, item in pairs(itemsFolder:GetChildren()) do
                        local ok2, data = pcall(function() return require(item) end)
                        if ok2 and data and data.Data and data.Data.Id == itemId then actualData = data.Data; break end
                    end
                end
            end
        end)

        if actualData then
            fishName = actualData.Name or actualData.DisplayName or fishName
            fishTier = tonumber(actualData.Tier) or 0
        end

        if inventoryData and inventoryData.InventoryItem then
            local invItem = inventoryData.InventoryItem
            uuid = invItem.UUID or nil
            sellPrice = invItem.SellPrice or 0
            if uuid then table.insert(obtainedFishUUIDs, uuid) end
        end
        -- WEBHOOK SEND (menggunakan ShouldSendWebhook) - logic from script 1
        if ShouldSendWebhook(fishName, fishTier) then
            task.spawn(function()
                task.wait(0.5)
                SendWebhook(fishName, fishTier, sellPrice, (fishTier==7 and "Secret") or (fishTier==6 and "Mythic") or (fishTier==5 and "Legendary") or "Common")
            end)
        end
    end)

    return true
end
-- ============================
-- UI: WEBHOOK TAB (moved from script 1, logic unchanged)
-- ============================
local WebhookTab = Window:Tab({ Title = "Webhook", Icon = "globe", ShowTabTitle = true, })

WebhookTab:Section({ Title = "Webhook Settings" })

WebhookTab:Toggle({
    Title = "Enable Webhook",
    Value = WebhookConfig.Enabled,
    Callback = function(v)
        WebhookConfig.Enabled = v
    end
})

WebhookTab:Input({
    Title = "Webhook URL",
    Placeholder = WebhookConfig.Url,
    Callback = function(v)
        WebhookConfig.Url = v
    end
})

WebhookTab:Dropdown({
    Title = "Webhook Categories",
    Values = {"Secret","Mythic","Legendary"},
    Value = WebhookConfig.SelectedCategories,
    Multi = true,
    Callback = function(v)
        WebhookConfig.SelectedCategories = v
    end
})

WebhookTab:Button({
    Title = "Test Webhook",
    Callback = function()
        if WebhookConfig.Url ~= "" then
            SendWebhook("Test Fish", 6, 123456, "Mythic")
        end
    end
})
-- ============================
-- INITIALIZE
-- ============================
task.spawn(function()
    task.wait(0.25)
    SetupRemoteReferences()
    task.wait(0.25)
    SetupSimpleListener()
    Notify({ Title = "AVholker Hub", Content = "Owner Ganteng :p Owner Ganteng :p", Duration = 4 })
    print("AVholker Hub - Owner Ganteng :p Owner Ganteng :p")
end)

---------------------------------------------------
-- üå¶Ô∏è TAB: AUTO BUY WEATHER (MULTISELECT + LOOP)
---------------------------------------------------
local AutoWeatherTab = Window:Tab({
    Title = "Auto Buy",
    Icon = "shopping-bag",
    ShowTabTitle = true,
})

local ParSection = AutoWeatherTab:Section({
    Title = "Auto Buy Weather",
    TextSize = 20,
    Opened = true,
})

local RFPurchaseWeatherEvent = Net["RF/PurchaseWeatherEvent"]
local weatherList = {"Wind", "Cloudy", "Snow", "Storm", "Radiant", "Shark Hunt"}
local selectedWeathers = {}
local autoBuyLoopEnabled = false

-- üå¶Ô∏è Dropdown Multiselect
ParSection:Dropdown({
    Title = "Select Weather Types",
    Desc = "Pilih beberapa cuaca yang ingin dibeli",
    Values = weatherList,
    Default = {"Wind"},
    Multi = true, -- ‚úÖ multiselect aktif
    Callback = function(values)
        selectedWeathers = values
        print("[üå¶Ô∏è AVholker] Cuaca terpilih:", table.concat(values, ", "))
    end
})

-- ‚òÄÔ∏è Button Manual Beli Cuaca
ParSection:Button({
    Title = "üå§Ô∏è Purchase Selected Weather",
    Desc = "click untuk membeli semua cuaca yang dipilih",
    Callback = function()
        for _, weather in ipairs(selectedWeathers) do
            pcall(function()
                RFPurchaseWeatherEvent:InvokeServer(weather)
                print("[üå¶Ô∏è AVholker] Membeli cuaca:", weather)
            end)
        end
    end
})

-- üîÅ Toggle Auto Buy Loop (setiap 4 detik)
local ToggleAutoBuyWeather = ParSection:Toggle({
    Title = "Auto Buy wather NS",
    Desc = "Turn ON For Auto buy weather nonstop",
    Icon = "cloudy",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        autoBuyLoopEnabled = state
        print("[üå¶Ô∏è AVholker] Auto Buy Loop:", state and "ON" or "OFF")

        if state then
            task.spawn(function()
                while autoBuyLoopEnabled do
                    for _, weather in ipairs(selectedWeathers) do
                        pcall(function()
                            RFPurchaseWeatherEvent:InvokeServer(weather)
                            print("[üå¶Ô∏è AVholker] Auto-buy cuaca:", weather)
                        end)
                    end
                    task.wait(4) -- ‚è≥ delay loop 4 detik
                end
            end)
        end
    end
})

-------------------------------------------------------
-- SECTION 3: FISHING TOOLS (Radar + Diving Gear + Oxygen)
-------------------------------------------------------

local FishingToolsTab = Window:Tab({
    Title = "Fishing Tools",
    Icon = "fish",
    ShowTabTitle = true,
})

-------------------------------------------------------
-- üëâ SECTION 3E: INFINITE ZOOM (NO SLIDER)
-------------------------------------------------------

local InfiniteZoomSection = FishingToolsTab:Section({
    Title = "Infinite Zoom",
    TextSize = 20,
    Opened = true,
})

local InfiniteZoom = {
    Enabled = false,
    OriginalMax = nil,
    OriginalMin = nil,
    ZoomDistance = 1e9, -- sangat jauh, tapi tetap bisa di-zoom in/out pakai scroll
}

local function ApplyInfiniteZoom()
    local plr = Players.LocalPlayer
    if not plr then return end

    -- simpan nilai asli sekali saja
    if InfiniteZoom.OriginalMax == nil then
        InfiniteZoom.OriginalMax = plr.CameraMaxZoomDistance
    end
    if InfiniteZoom.OriginalMin == nil then
        InfiniteZoom.OriginalMin = plr.CameraMinZoomDistance
    end

    plr.CameraMaxZoomDistance = InfiniteZoom.ZoomDistance
    plr.CameraMinZoomDistance = 0.5 -- biar masih bisa zoom dekat
end

local function ResetZoom()
    local plr = Players.LocalPlayer
    if not plr then return end

    if InfiniteZoom.OriginalMax ~= nil then
        plr.CameraMaxZoomDistance = InfiniteZoom.OriginalMax
    end
    if InfiniteZoom.OriginalMin ~= nil then
        plr.CameraMinZoomDistance = InfiniteZoom.OriginalMin
    end
end

local function SetInfiniteZoom(state)
    InfiniteZoom.Enabled = state
    if state then
        ApplyInfiniteZoom()
        WindUI:Notify({
            Title = "Infinite Zoom",
            Content = "Infinite Zoom Enabled",
            Duration = 2,
            Icon = "zoom-in"
        })
    else
        ResetZoom()
        WindUI:Notify({
            Title = "Infinite Zoom",
            Content = "Infinite Zoom Disabled",
            Duration = 2,
            Icon = "zoom-out"
        })
    end
end

InfiniteZoomSection:Toggle({
    Title = "Enable Infinite Zoom",
    Desc = "ZOOM ZOOM ZOOM",
    Type = "Toggle",
    Value = false,
    Callback = function(v)
        SetInfiniteZoom(v)
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Net = ReplicatedStorage
    :WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")


-------------------------------------------------------
-- üëâ SECTION 3A: FISHING RADAR (UI ONLY UPDATED)
-------------------------------------------------------

local RadarSection = FishingToolsTab:Section({
    Title = "Fishing Radar",
    TextSize = 20,
    Opened = true,
})

local Radar = {
    Enabled = false,
    Remote = Net:WaitForChild("RF/UpdateFishingRadar")
}

function Radar:Set(state)
    self.Enabled = state
    if self.Remote then
        self.Remote:InvokeServer(state)
    end
end

RadarSection:Toggle({
    Title = "Enable Fishing Radar",
    Desc = "",
    Icon = "",
    Type = "Toggle",
    Callback = function(v)
        Radar:Set(v)
    end
})


-------------------------------------------------------
-- üëâ SECTION 3B: DIVING GEAR (UI ONLY UPDATED)
-------------------------------------------------------

local DivingSection = FishingToolsTab:Section({
    Title = "Diving Gear",
    TextSize = 20,
    Opened = true,
})

local Diving = {
    Enabled = false,
    EquipRemote = Net:WaitForChild("RF/EquipOxygenTank"),
    UnequipRemote = Net:WaitForChild("RF/UnequipOxygenTank")
}

function Diving:Equip()
    if self.EquipRemote then
        self.EquipRemote:InvokeServer(105)
    end
end

function Diving:Unequip()
    if self.UnequipRemote then
        self.UnequipRemote:InvokeServer()
    end
end

function Diving:Set(state)
    self.Enabled = state
    if state then
        self:Equip()
    else
        self:Unequip()
    end
end

DivingSection:Toggle({
    Title = "Equip Diving Gear",
    Desc = "",
    Icon = "",
    Type = "Toggle",
    Callback = function(v)
        Diving:Set(v)
    end
})


-------------------------------------------------------
-- üëâ SECTION 3C: BYPASS OXYGEN (UI ONLY UPDATED)
-------------------------------------------------------

local OxygenSection = FishingToolsTab:Section({
    Title = "Bypass Oxygen",
    TextSize = 20,
    Opened = true,
})

local OxygenBypass = {
    Enabled = false,
    Remote = nil,
    Backup = nil,
}

local function GetOxygenRemote()
    local ok, rem = pcall(function()
        return Net:FindFirstChild("URE/UpdateOxygen")
    end)
    if ok and rem then
        return rem
    end
    return nil
end

-- ENABLE BYPASS (logika tidak diubah sama sekali)
function OxygenBypass:Enable()
    if self.Enabled then return end
    self.Enabled = true

    local remote = GetOxygenRemote()
    if not remote then
        warn("[OXY] Remote not found.")
        return
    end

    self.Backup = remote:Clone()
    self.Backup.Parent = remote.Parent

    remote:Destroy()

    self.Remote = nil

    warn("[OXY] BYPASS ACTIVE (remote destroyed locally)")
end

-- DISABLE BYPASS (logika tetap)
function OxygenBypass:Disable()
    if not self.Enabled then return end
    self.Enabled = false

    local existing = GetOxygenRemote()
    if existing then
        existing:Destroy()
    end

    if self.Backup then
        self.Backup.Parent = Net
        self.Backup.Name = "URE/UpdateOxygen"
        self.Backup = nil
    end

    warn("[OXY] BYPASS DISABLED (remote restored)")
end

OxygenSection:Toggle({
    Title = "Enable Bypass Oxygen",
    Desc = "",
    Icon = "",
    Type = "Toggle",
    Value = false,
    Callback = function(state)
        if state then
            OxygenBypass:Enable()
        else
            OxygenBypass:Disable()
        end
    end
})

-------------------------------------------------------
-- üëâ SECTION 3D: WALK ON WATER (ALL FUNCTIONS KEPT)
-------------------------------------------------------

local WalkWaterSection = FishingToolsTab:Section({
    Title = "Walk On Water",
    TextSize = 20,
    Opened = true,
})

-------------------------------------------------------
--  FULL ORIGINAL LOGIC (NO CHANGES)
-------------------------------------------------------

-- SERVICES
local Players    = game:GetService("Players")
local Workspace  = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
if not player then
    warn("Player not found (LocalScript).")
end

-- CHARACTER REFS
local Character        = player.Character or player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 5)
local Humanoid         = Character:FindFirstChildOfClass("Humanoid")

local function RefreshCharacterRefs(char)
    Character        = char
    HumanoidRootPart = char:WaitForChild("HumanoidRootPart", 5)
    Humanoid         = char:FindFirstChildOfClass("Humanoid")
end

player.CharacterAdded:Connect(function(char)
    RefreshCharacterRefs(char)
end)

-- CONFIG
local WalkConfig = {
    WalkOnWater = false
}

-- CORE VARS
local WalkOnWaterConnection = nil
local WaterPlatform = nil

local FULL_PLATFORM_SIZE = Vector3.new(2048, 1, 2048)
local WATER_Y_LEVEL      = -1.5

-- CREATE PLATFORM
local function CreateWaterPlatform()
    if WaterPlatform and WaterPlatform.Parent then
        return WaterPlatform
    end

    local part = Instance.new("Part")
    part.Name       = "AVH_WaterPlatform_Follow"
    part.Size       = FULL_PLATFORM_SIZE
    part.Anchored   = true
    part.CanCollide = true
    part.Transparency = 1
    part.Material     = Enum.Material.SmoothPlastic
    part.Color        = Color3.fromRGB(150,200,255)
    part.Position     = Vector3.new(0, WATER_Y_LEVEL, 0)
    part.Parent       = Workspace

    WaterPlatform = part
    return part
end

local function DestroyWaterPlatform()
    if WaterPlatform then
        if WaterPlatform.Parent then WaterPlatform:Destroy() end
        WaterPlatform = nil
    end
end

-- MAIN TOGGLE
local function ToggleWalkOnWater(enabled)
    WalkConfig.WalkOnWater = enabled

    if WalkOnWaterConnection then
        WalkOnWaterConnection:Disconnect()
        WalkOnWaterConnection = nil
    end

    if not enabled then
        DestroyWaterPlatform()
        return
    end

    CreateWaterPlatform()

    WalkOnWaterConnection = RunService.Heartbeat:Connect(function()
        pcall(function()
            if not Character or not Character.Parent then
                Character = player.Character
            end
            if Character and (not HumanoidRootPart or not HumanoidRootPart.Parent) then
                HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            end
            if Character and (not Humanoid or not Humanoid.Parent) then
                Humanoid = Character:FindFirstChildOfClass("Humanoid")
            end
            if not (Character and HumanoidRootPart and Humanoid) then return end

            if not WaterPlatform or not WaterPlatform.Parent then
                CreateWaterPlatform()
            end

            local pos = HumanoidRootPart.Position

            WaterPlatform.Position = Vector3.new(
                pos.X,
                WATER_Y_LEVEL,
                pos.Z
            )
        end)
    end)
end

-------------------------------------------------------
--  UI CONTROL (NO LOGIC CHANGE)
-------------------------------------------------------

WalkWaterSection:Toggle({
    Title = "Enable Walk On Water",
    Desc = "",
    Type = "Toggle",
    Value = WalkConfig.WalkOnWater,
    Callback = function(v)
        ToggleWalkOnWater(v)

        WindUI:Notify({
            Title = "Walk On Water",
            Content = v and "Enabled" or "Disabled",
            Duration = 2,
            Icon = "waves"
        })
    end
})

local TeleportTab = Window:Tab({ Title = "Teleport & Events", Icon = "rocket", ShowTabTitle = true })

---------------------------------------------------
-- üåç Teleport to Player
---------------------------------------------------
-- Teleport
TeleportTab:Section({
    Title = " Teleport to player",
    Description = "Click!",
})
-- Function untuk memilih player dari daftar
local selectedPlayer = nil  -- Deklarasi variable selectedPlayer

local function getPlayersList()
    local playerNames = {}
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player.Name ~= game.Players.LocalPlayer.Name then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Membuat dropdown dengan nama pemain yang tersedia
local Dropdown = TeleportTab:Dropdown({
    Title = "Select Player",
    Values = getPlayersList(),
    Value = getPlayersList()[1],  -- Default value, pertama kali akan memilih player pertama
    Callback = function(selectedPlayerName)
        -- Store selected player
        selectedPlayer = selectedPlayerName
    end
})

-- Fungsi untuk memperbarui dropdown dengan daftar pemain
Dropdown:Refresh(getPlayersList())

-- Button for teleporting to the selected player
local TeleportButton = TeleportTab:Button({
    Title = "Teleport to Selected Player",
    Desc = "Click to teleport to the selected player",
    Locked = false,
    Callback = function()
        if selectedPlayer then
            local targetPlayer = game:GetService("Players"):FindFirstChild(selectedPlayer)
            if targetPlayer and targetPlayer.Character then
                local localPlayer = game:GetService("Players").LocalPlayer
                if localPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character:MoveTo(targetPlayer.Character.HumanoidRootPart.Position)
                    print("Teleporting to " .. selectedPlayer)
                end
            end
        else
            print("No player selected.")
        end
    end
})

-- Auto Loop Teleport (Updated Toggle)
local AutoLoopEnabled = false
local TeleportInterval = 0  -- Time interval between teleport actions (in seconds)

local function startAutoLoop()
    while AutoLoopEnabled do
        if selectedPlayer then
            local targetPlayer = game:GetService("Players"):FindFirstChild(selectedPlayer)
            if targetPlayer and targetPlayer.Character then
                local localPlayer = game:GetService("Players").LocalPlayer
                if localPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character:MoveTo(targetPlayer.Character.HumanoidRootPart.Position)
                    print("Teleporting to " .. selectedPlayer)
                end
            end
        else
            print("No player selected.")
        end
        wait(TeleportInterval)  -- Wait before teleporting again
    end
end

-- New Toggle to control Auto Loop teleportation
TeleportTab:Toggle({
    Title = "Enable Auto Loop Teleport",
    Desc = "Toggle auto teleporting to the selected player.",
    Icon = "repeat",
    Type = "Checkbox",  -- Changed to Checkbox type
    Default = false,
    Callback = function(state)
        AutoLoopEnabled = state
        if AutoLoopEnabled then
            startAutoLoop()  -- Start the auto loop when enabled
            print("Auto Loop Teleport enabled.")
        else
            print("Auto Loop Teleport disabled.")
        end
    end
})

-- Auto Refresh Daftar Player
game:GetService("Players").PlayerAdded:Connect(function()
    -- Update daftar pemain saat pemain baru bergabung
    Dropdown:Refresh(getPlayersList())
end)

game:GetService("Players").PlayerRemoving:Connect(function()
    -- Update daftar pemain saat pemain keluar
    Dropdown:Refresh(getPlayersList())
end)


-- ============================
-- TELEPORT / EVENT SCANNER
-- ============================
local IslandLocations = {
    ["Weather Machine"] = Vector3.new(-1471, -3, 1929),
    ["Esoteric Depths"] = Vector3.new(3157, -1303, 1439),
    ["Tropical Grove"] = Vector3.new(-2038, 3, 3650),
    ["Stingray Shores"] = Vector3.new(-32, 4, 2773),
    ["Kohana Volcano"] = Vector3.new(-519, 24, 189),
    ["Coral Reefs"] = Vector3.new(-3095, 1, 2177),
    ["Crater Island"] = Vector3.new(968, 1, 4854),
    ["Kohana"] = Vector3.new(-658, 3, 719),
    ["Winter Fest"] = Vector3.new(1611, 4, 3280),
    ["Fisherman Island"] = Vector3.new(92, 9, 2768),
    ["Ancient Jungle"] = Vector3.new(1481, 11, -302),
    ["Sisyphus Statue"] = Vector3.new(-3740, -136, -1013),
    ["Secreet temple"] = Vector3.new(1487, -22, -622),
}

local function ScanActiveEvents()
    local events = {}
    local validEvents = {
        "megalodon","whale","kraken","hunt","ghost worm","mount hallow",
        "admin","hallow bay","worm","blackhole","halloweenfasttravel"
    }

    for _, object in pairs(Workspace:GetDescendants()) do
        if object:IsA("Model") or object:IsA("Folder") then
            local name = object.Name:lower()

            for _, keyword in ipairs(validEvents) do
                if name:find(keyword) and not name:find("boat") and not name:find("sharki") then
                    
                    local exists = false
                    for _, e in ipairs(events) do
                        if e.Name == object.Name then
                            exists = true
                            break
                        end
                    end

                    if not exists then
                        local position = Vector3.new(0,0,0)

                        if object:IsA("Model") then
                            pcall(function() position = object:GetPivot().Position end)

                        elseif object:IsA("BasePart") then
                            position = object.Position

                        elseif object:IsA("Folder") and #object:GetChildren() > 0 then
                            local child = object:GetChildren()[1]
                            if child:IsA("Model") then
                                pcall(function() position = child:GetPivot().Position end)
                            elseif child:IsA("BasePart") then
                                position = child.Position
                            end
                        end

                        table.insert(events, {
                            Name = object.Name,
                            Object = object,
                            Position = position
                        })
                    end

                    break
                end
            end
        end
    end

    return events
end

local function TeleportToEventPosition(position)
    local ok = pcall(function()
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart", 3)
        if not hrp then return end

        for _, obj in ipairs(Workspace:GetChildren()) do
            if obj:IsA("Part") and obj.Name == "AVH_EventPlatform" then
                obj:Destroy()
            end
        end

        local platform = Instance.new("Part")
        platform.Name = "AVH_EventPlatform"
        platform.Size = Vector3.new(10, 1, 10)
        platform.Anchored = true
        platform.CanCollide = true
        platform.Transparency = 0.4
        platform.Color = Color3.fromRGB(150, 200, 255)
        platform.Material = Enum.Material.ForceField
        platform.Position = position + Vector3.new(0, 12, 0)
        platform.Parent = Workspace

        hrp.CFrame = CFrame.new(platform.Position + Vector3.new(0, 3, 0))
        task.wait(0.5)
    end)

    return ok
end

-- ------------------------------------------
-- TELEPORT LIST
-- ------------------------------------------
TeleportTab:Section({ Title = "Teleports" })

for islandName, pos in pairs(IslandLocations) do
    TeleportTab:Button({
        Title = islandName,
        Callback = function()
            pcall(function()
                local char = player.Character or player.CharacterAdded:Wait()
                local hrp = char:WaitForChild("HumanoidRootPart", 3)
                if hrp then hrp.CFrame = CFrame.new(pos + Vector3.new(0,5,0)) end
                Notify({ Title = "Teleport Success", Content = "Teleported to "..islandName, Duration = 2 })
            end)
        end
    })
end

-- ------------------------------------------
-- FIXED EVENT DROPDOWN (FINAL)
-- ------------------------------------------
TeleportTab:Section({ Title = "Active Events" })

local FixedEventList = {
    "‚Äî Select Event ‚Äî",  
    "Shark Hunt",
    "Ghost Shark Hunt",
    "Worm Hunt",
    "Black Hole",
    "Shocked",
    "Ghost Worm",
    "Meteor Rain",
    "Megalodom Hunt"
}

local EventKeywords = {
    ["Shark Hunt"]        = {"shark", "hunt"},
    ["Ghost Shark Hunt"]  = {"ghost", "shark"},
    ["Worm Hunt"]         = {"worm", "hunt"},
    ["Black Hole"]        = {"black", "hole", "blackhole"},
    ["Shocked"]           = {"shock", "electric"},
    ["Ghost Worm"]        = {"ghost", "worm"},
    ["Meteor Rain"]       = {"meteor", "rain"},
    ["Megalodom Hunt"]    = {"mega", "megalodon", "hunt"},
}

local function GetActiveEventByName(selectedEvent)
    local keywords = EventKeywords[selectedEvent]
    if not keywords then return nil end

    local events = ScanActiveEvents()

    for _, ev in ipairs(events) do
        local lowerName = ev.Name:lower()

        for _, key in ipairs(keywords) do
            if lowerName:find(key) then
                return ev
            end
        end
    end
    return nil
end

TeleportTab:Dropdown({
    Title = "Active Events",
    Desc = "Select event to teleport (only if active)",
    Values = FixedEventList,
    Value = "‚Äî Select Event ‚Äî",
    Callback = function(selected)
        
        if selected == "‚Äî Select Event ‚Äî" then
            return
        end

        local ev = GetActiveEventByName(selected)

        if not ev then
            Notify({
                Title = "Event Not Active",
                Content = selected .. " is not active right now.",
                Duration = 2
            })
            return
        end

        TeleportToEventPosition(ev.Position)

        Notify({
            Title = "Teleport Success",
            Content = "Teleported to " .. ev.Name,
            Duration = 2
        })
    end
})


---------------------------------------------------
-- üåà Tab Theme
---------------------------------------------------
local ThemeTab = Window:Tab({
    Title = "üé® Theme",
    Icon = "palette",
    ShowTabTitle = true 
})

-- üß© Ganti tema dengan aman
local function SafeSetTheme(theme)
    if Window.SetTheme then
        Window:SetTheme(theme)
    elseif WindUI.SetTheme then
        WindUI:SetTheme(theme)
    end
end

-- üé® SECTION: Theme Settings
ThemeTab:Section({ Title = "Theme Settings" })

ThemeTab:Dropdown({
    Title = "Choose Theme",
    Values = {
        "Crimson","Emerald","CottonCandy","Light","Royal Void",
        "Amber","Sky","Rose","Rainbow","Violet","Midnight","Dark","MonkaiPro","Indigo","Plant","Red"
    },
    Default = "Crimson",
    Callback = function(selectedTheme)
        SafeSetTheme(selectedTheme)
    end
})

-- üé® SECTION: Theme Reset
ThemeTab:Button({
    Title = "Reset Theme Default",
    Icon = "rotate-ccw",
    Callback = function()
        SafeSetTheme("Crimson")
    end
})

-- üé® SECTION: Background Settings
ThemeTab:Section({ Title = "preset Background Settings" })

local backgroundOptions = {
    {"Luffy1", "rbxassetid://11286223267"},
    {"Luffy2", "rbxassetid://136828309113388"},
    {"Gojo Satoru", "rbxassetid://7801572665"},
    {"Venom", "rbxassetid://13398051334"}
}

ThemeTab:Dropdown({
    Title = "choose preset",
    Values = {"Luffy1", "Luffy2", "Gojo Satoru", "Venom"},
    Default = "Luffy1",
    Callback = function(selectedBackground)
        for _, option in pairs(backgroundOptions) do
            if option[1] == selectedBackground then
                if Window.SetBackgroundImage then
                    Window:SetBackgroundImage(option[2])
                end
                break
            end
        end
    end
})

ThemeTab:Toggle({
    Title = "Active Preset",
    Default = true,
    Callback = function(isEnabled)
        if not Window.SetBackgroundImage then return end
        if isEnabled then
            for _, option in pairs(backgroundOptions) do
                if option[1] == "Luffy2" then
                    Window:SetBackgroundImage(option[2])
                    break
                end
            end
        else
            Window:SetBackgroundImage("rbxassetid://")
        end
    end
})


  ---------------------------------------------------
    -- ‚ú® TAB BARU: MISC (DIPINDAHKAN DI SINI ‚Äî DI BAWAH AUTO FUSE)
    ---------------------------------------------------
    local MiscTab = Window:Tab({
        Title = "Misc",
        Icon = "settings", 
        ShowTabTitle = true 
    })

    ---------------------------------------------------
    -- ü¶Ö SECTION: AUTO FLY
    ---------------------------------------------------
    local FlySection = MiscTab:Section({ Title = "Fly Mode" })

    -- Variabel dasar fly
    local flying = false
    local flySpeed = 5
    local flyConnection

    FlySection:Toggle({
        Title = "ü¶Ö Turn ON Fly mode",
        Desc = "Aktifkan mode terbang dengan tombol ini!",
        Icon = "bird",
        Type = "Checkbox",
        Default = false,
        Callback = function(state)
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:WaitForChild("HumanoidRootPart")
            local humanoid = character:WaitForChild("Humanoid")

            flying = state

            if flying then
                print("ü¶Ö Fly mode diaktifkan!")

                local pos = Instance.new("BodyPosition")
                local gyro = Instance.new("BodyGyro")
                pos.Position = hrp.Position
                pos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                pos.P = 100000
                pos.D = 1750
                pos.Parent = hrp
                gyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                gyro.P = 100000
                gyro.D = 2200
                gyro.Parent = hrp
                humanoid.PlatformStand = true

                flyConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    if not flying then return end

                    local cam = workspace.CurrentCamera
                    local dir = cam.CFrame:VectorToObjectSpace(humanoid.MoveDirection * flySpeed)
                    if dir.Magnitude == 0 then
                        dir = Vector3.new(0, 0, 0)
                    else
                        dir = cam.CFrame:VectorToWorldSpace(Vector3.new(dir.X, 0, dir.Z).Unit * dir.Magnitude)
                    end
                    pos.Position = pos.Position + dir
                    gyro.CFrame = cam.CFrame

                    for _, part in pairs(character:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end)
            else
                print("üõ¨ Fly mode dimatikan!")

                if flyConnection then
                    flyConnection:Disconnect()
                    flyConnection = nil
                end

                if hrp:FindFirstChild("BodyPosition") then
                    hrp.BodyPosition:Destroy()
                end
                if hrp:FindFirstChild("BodyGyro") then
                    hrp.BodyGyro:Destroy()
                end

                humanoid.PlatformStand = false
            end
        end
    })

    FlySection:Slider({
        Title = "üåÄ Fly Speed",
        Step = 1,
        Value = { Min = 1, Max = 20, Default = flySpeed },
        Callback = function(Value)
            flySpeed = Value
            print("‚ö° Kecepatan terbang diatur ke:", flySpeed)
        end
    })

    FlySection:Input({
        Title = "‚öôÔ∏è Input Fly Speed",
        Desc = "Masukkan kecepatan terbang secara manual!",
        PlaceholderText = "Contoh: 10",
        RemoveTextAfterFocusLost = false,
        Required = false,
        Default = tostring(flySpeed),
        Numeric = true,
        Callback = function(Value)
            local number = tonumber(Value)
            if number and number >= 1 and number <= 10000 then
                flySpeed = number
                print("‚úàÔ∏è Kecepatan terbang diset ke:", flySpeed)
            else
                warn("‚ö†Ô∏è Nilai tidak valid! Harus antara 1-10000.")
            end
        end
    })

    ---------------------------------------------------
    -- üí§ SECTION: ANTI AFK
    ---------------------------------------------------
    local AntiAFKSection = MiscTab:Section({ Title = "Anti AFK" })


-- State untuk toggle Anti-AFK
local AntiAFKEnabled = true

-- VirtualUser untuk Anti-AFK
local bb = game:service'VirtualUser'

-- Fungsi untuk mengaktifkan Anti-AFK
local function enableAntiAFK()
    game:service'Players'.LocalPlayer.Idled:connect(function()
        bb:CaptureController()
        bb:ClickButton2(Vector2.new())
    end)
end

-- Fungsi untuk menonaktifkan Anti-AFK
local function disableAntiAFK()
    -- Tidak perlu menghentikan event karena event 'Idled' tidak dapat dihentikan langsung
    -- Kita bisa hanya mengatur statusnya agar tidak aktif
    -- Untuk fitur lebih canggih, bisa tambahkan variabel status atau kondisi lain
end

-- Membuat toggle untuk Anti-AFK menggunakan WindUI Toggle format
AntiAFKSection:Toggle({
    Title = "Turn ON Anti-AFK",  -- Toggle Name
    Desc = "Aktifkan atau nonaktifkan fitur Anti-AFK.",  -- Toggle Description
    Icon = "shield",  -- Icon for the toggle
    Type = "Checkbox",  -- Type of toggle (Checkbox)
    Value = true,  -- Default state (false = disabled)
    Callback = function(state)  -- Callback function when toggle is changed
        AntiAFKEnabled = state
        if AntiAFKEnabled then
            enableAntiAFK()  -- Aktifkan Anti-AFK
        else
            disableAntiAFK()  -- Nonaktifkan Anti-AFK
        end
    end
})

    ---------------------------------------------------
    -- üèÉ SECTION: WALK SPEED BOOST
    ---------------------------------------------------
    local WalkSpeedSection = MiscTab:Section({ Title = "Walk Speed" })

    local defaultSpeed = 16
    local currentSpeed = defaultSpeed

    WalkSpeedSection:Slider({
        Title = "‚ö° Run Speed",
        Step = 1,
        Value = { Min = 10, Max = 100, Default = defaultSpeed },
        Callback = function(Value)
            currentSpeed = Value
            local char = game.Players.LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                char:FindFirstChildOfClass("Humanoid").WalkSpeed = currentSpeed
                print("‚ö° WalkSpeed diset ke:", currentSpeed)
            end
        end
    })

    WalkSpeedSection:Button({
        Title = "üîÑ Reset Speed",
        Desc = "Kembalikan WalkSpeed ke nilai default",
        Callback = function()
            local char = game.Players.LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                char:FindFirstChildOfClass("Humanoid").WalkSpeed = defaultSpeed
                currentSpeed = defaultSpeed
                print("‚úÖ WalkSpeed dikembalikan ke default (16)")
            end
        end
    })

    ---------------------------------------------------
    -- üéÆ SECTION: NO CLIP MODE
    ---------------------------------------------------
    local NoClipSection = MiscTab:Section({ Title = "No Clip Mode" })

    local noclip = false
    local noclipConnection

    NoClipSection:Toggle({
        Title = "üéÆ Mode Noclip",
        Desc = "Aktifkan untuk menembus tembok!",
        Icon = "ghost",
        Type = "Checkbox",
        Default = false,
        Callback = function(state)
            noclip = state
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()

            if noclip then
                print("üéÆ NoClip diaktifkan ‚Äî kamu bisa nembus tembok sekarang!")
                noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                    if character and character:FindFirstChildOfClass("Humanoid") then
                        for _, part in pairs(character:GetChildren()) do
                            if part:IsA("BasePart") then part.CanCollide = false end
                        end
                    end
                end)
            else
                print("üö™ NoClip dimatikan ‚Äî tabrakan kembali normal.")
                if noclipConnection then noclipConnection:Disconnect() noclipConnection=nil end
                if character then
                    for _, part in pairs(character:GetChildren()) do
                        if part:IsA("BasePart") then part.CanCollide = true end
                    end
                end
            end
        end
    })

    ---------------------------------------------------
    -- ü¶ò SECTION: INFINITE JUMP
    ---------------------------------------------------
    local InfiniteJumpSection = MiscTab:Section({ Title = "Infinite Jump" })

    local infiniteJumpEnabled = false
    local UserInputService = game:GetService("UserInputService")

    InfiniteJumpSection:Toggle({
        Title = "ü¶ò Turn ON Infinite Jump",
        Desc = "Jump And Jump",
        Icon = "chevrons-up",
        Type = "Checkbox",
        Default = false,
        Callback = function(state)
            infiniteJumpEnabled = state
            if infiniteJumpEnabled then
                print("ü¶ò Infinite Jump aktif!")
            else
                print("üö´ Infinite Jump dimatikan.")
            end
        end
    })

    -- Event listener untuk lompat tanpa batas
    UserInputService.JumpRequest:Connect(function()
        if infiniteJumpEnabled then
            local player = game.Players.LocalPlayer
            local char = player.Character or player.CharacterAdded:Wait()
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)


